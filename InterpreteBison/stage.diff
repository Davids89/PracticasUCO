diff --git a/EjemplosBasicos/ejemplo1/Makefile b/EjemplosBasicos/ejemplo1/Makefile
new file mode 100644
index 0000000..7464fa7
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/Makefile
@@ -0,0 +1,27 @@
+FUENTE = ejemplo1
+LEXICO = lexico1
+
+CC = gcc
+YFLAGS = -d 
+LFLAGS = -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o 
+
+(FUENTE).exe : $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe 
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c 
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h  $(FUENTE).h 
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o: $(FUENTE).tab.c  $(FUENTE).tab.h   $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros auxiliares y los objetos
+clean: 
+	rm  -f $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe
+
diff --git a/EjemplosBasicos/ejemplo1/caca.txt b/EjemplosBasicos/ejemplo1/caca.txt
new file mode 100644
index 0000000..75afa3d
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/caca.txt
@@ -0,0 +1 @@
+Para crear la tabla LALR bison -v
diff --git a/EjemplosBasicos/ejemplo1/ejemplo1.h b/EjemplosBasicos/ejemplo1/ejemplo1.h
new file mode 100644
index 0000000..7c81809
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/ejemplo1.h
@@ -0,0 +1 @@
+#define YYSTYPE double  /*  tipos de datos de la pila de yacc */
diff --git a/EjemplosBasicos/ejemplo1/ejemplo1.output b/EjemplosBasicos/ejemplo1/ejemplo1.output
new file mode 100644
index 0000000..4829592
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/ejemplo1.output
@@ -0,0 +1,256 @@
+Gramática
+
+    0 $accept: list $end
+
+    1 list: %empty
+    2     | list '\n'
+    3     | list expr '\n'
+
+    4 expr: NUMBER
+    5     | expr '+' expr
+    6     | expr '-' expr
+    7     | expr '*' expr
+    8     | expr '/' expr
+    9     | '(' expr ')'
+   10     | '-' expr
+
+
+Terminales con las reglas donde aparecen
+
+$end (0) 0
+'\n' (10) 2 3
+'(' (40) 9
+')' (41) 9
+'*' (42) 7
+'+' (43) 5
+'-' (45) 6 10
+'/' (47) 8
+error (256)
+NUMBER (258) 4
+UNARYMINUS (259)
+
+
+No terminales con las reglas donde aparecen
+
+$accept (12)
+    en la izquierda: 0
+list (13)
+    en la izquierda: 1 2 3, en la derecha: 0 2 3
+expr (14)
+    en la izquierda: 4 5 6 7 8 9 10, en la derecha: 3 5 6 7 8 9 10
+
+
+State 0
+
+    0 $accept: . list $end
+
+    $default  reduce usando la regla 1 (list)
+
+    list  ir al estado 1
+
+
+State 1
+
+    0 $accept: list . $end
+    2 list: list . '\n'
+    3     | list . expr '\n'
+
+    $end    desplazar e ir al estado 2
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '\n'    desplazar e ir al estado 5
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 7
+
+
+State 2
+
+    0 $accept: list $end .
+
+    $default  aceptar
+
+
+State 3
+
+    4 expr: NUMBER .
+
+    $default  reduce usando la regla 4 (expr)
+
+
+State 4
+
+   10 expr: '-' . expr
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 8
+
+
+State 5
+
+    2 list: list '\n' .
+
+    $default  reduce usando la regla 2 (list)
+
+
+State 6
+
+    9 expr: '(' . expr ')'
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 9
+
+
+State 7
+
+    3 list: list expr . '\n'
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+
+    '+'   desplazar e ir al estado 10
+    '-'   desplazar e ir al estado 11
+    '*'   desplazar e ir al estado 12
+    '/'   desplazar e ir al estado 13
+    '\n'  desplazar e ir al estado 14
+
+
+State 8
+
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+   10     | '-' expr .
+
+    $default  reduce usando la regla 10 (expr)
+
+
+State 9
+
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+    9     | '(' expr . ')'
+
+    '+'  desplazar e ir al estado 10
+    '-'  desplazar e ir al estado 11
+    '*'  desplazar e ir al estado 12
+    '/'  desplazar e ir al estado 13
+    ')'  desplazar e ir al estado 15
+
+
+State 10
+
+    5 expr: expr '+' . expr
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 16
+
+
+State 11
+
+    6 expr: expr '-' . expr
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 17
+
+
+State 12
+
+    7 expr: expr '*' . expr
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 18
+
+
+State 13
+
+    8 expr: expr '/' . expr
+
+    NUMBER  desplazar e ir al estado 3
+    '-'     desplazar e ir al estado 4
+    '('     desplazar e ir al estado 6
+
+    expr  ir al estado 19
+
+
+State 14
+
+    3 list: list expr '\n' .
+
+    $default  reduce usando la regla 3 (list)
+
+
+State 15
+
+    9 expr: '(' expr ')' .
+
+    $default  reduce usando la regla 9 (expr)
+
+
+State 16
+
+    5 expr: expr . '+' expr
+    5     | expr '+' expr .
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+
+    '*'  desplazar e ir al estado 12
+    '/'  desplazar e ir al estado 13
+
+    $default  reduce usando la regla 5 (expr)
+
+
+State 17
+
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    6     | expr '-' expr .
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+
+    '*'  desplazar e ir al estado 12
+    '/'  desplazar e ir al estado 13
+
+    $default  reduce usando la regla 6 (expr)
+
+
+State 18
+
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    7     | expr '*' expr .
+    8     | expr . '/' expr
+
+    $default  reduce usando la regla 7 (expr)
+
+
+State 19
+
+    5 expr: expr . '+' expr
+    6     | expr . '-' expr
+    7     | expr . '*' expr
+    8     | expr . '/' expr
+    8     | expr '/' expr .
+
+    $default  reduce usando la regla 8 (expr)
diff --git a/EjemplosBasicos/ejemplo1/ejemplo1.y b/EjemplosBasicos/ejemplo1/ejemplo1.y
new file mode 100644
index 0000000..f726025
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/ejemplo1.y
@@ -0,0 +1,70 @@
+/*
+ Ejemplo 1
+ 
+ Interpreta expresiones aritméticas: suma, resta, multiplicación y división
+ Permite expresiones entre paréntesis y el signo "-" unario
+ No permite el signo "+" unario
+ Las expresiones deben terminar con un salto de línea
+ 
+  El programa finaliza pulsando Control + D
+*/
+
+
+%{ 
+#include <stdio.h>
+
+#include "ejemplo1.h"  /*  tipos de datos de la pila de yacc */
+%}
+
+
+%token NUMBER
+%left '+' '-'   /* asociatividad a la izquierda; precedencia menor */
+%left '*' '/' /*esta tiene mas prioridad que la suma*/
+%left UNARYMINUS /* maxima precedencia */ 
+
+%%
+
+list :       /* nada: epsilon - produccion */
+        | list '\n'
+        | list expr '\n'  {printf("\t%.8g\n",$2);}
+        ;
+
+expr :    NUMBER        {$$ = $1;}  /* $$ es el atributo de la izquierda, $1 es NUMBER $2 no se pone pero es el signo y $3 es otro NUMBER*/
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '/' expr {$$ = $1 / $3;}
+        | '(' expr ')'  {$$ = $2;}
+        |'-' expr %prec UNARYMINUS { $$ = -$2; }
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ progname=argv[0];
+ yyparse();
+}
+
+
+/* Llamada en caso de error de sintaxis de yacc */
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+/* Imprime mensajes de aviso */
+
+warning(char *s, char *t)
+{
+ fprintf(stderr,"%s: %s", progname,s);
+ if (t) fprintf(stderr," %s ",t);
+ fprintf(stderr," en la linea %d \n",lineno);
+}
diff --git a/EjemplosBasicos/ejemplo1/lexico1.l b/EjemplosBasicos/ejemplo1/lexico1.l
new file mode 100644
index 0000000..caa60d6
--- /dev/null
+++ b/EjemplosBasicos/ejemplo1/lexico1.l
@@ -0,0 +1,28 @@
+%{
+#include <stdio.h>
+
+#include "ejemplo1.h"
+#include "ejemplo1.tab.h"
+
+
+/* extern YYSTYPE yylval; */
+extern char *progname;
+extern int lineno;
+%}
+/* definicion regular */
+
+numero   [0-9]
+  	
+%%
+[ \t] 		{ ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+  {
+                                    sscanf(yytext,"%lf",&yylval); //esta es la variable más importante de bison, se corresponde con $1 cuando es numero
+                                    return NUMBER; 
+                                    }
+
+\n      {lineno++; return '\n';}
+
+.       {return yytext[0];}
+%%
+
diff --git a/EjemplosBasicos/ejemplo2/Makefile b/EjemplosBasicos/ejemplo2/Makefile
new file mode 100644
index 0000000..fb1014b
--- /dev/null
+++ b/EjemplosBasicos/ejemplo2/Makefile
@@ -0,0 +1,27 @@
+FUENTE = ejemplo2
+LEXICO = lexico2
+
+CC = gcc
+YFLAGS = -d 
+LFLAGS = -lfl -lm  # fl: biblioteca de flex; m: biblioteca matemática
+
+OBJS= $(FUENTE).tab.o lex.yy.o 
+
+$(FUENTE).exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe 
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c 
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h  $(FUENTE).h 
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o: $(FUENTE).tab.c  $(FUENTE).tab.h   $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros auxiliares y los objetos
+clean: 
+	rm  -f $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe
diff --git a/EjemplosBasicos/ejemplo2/ejemplo2.h b/EjemplosBasicos/ejemplo2/ejemplo2.h
new file mode 100644
index 0000000..7c81809
--- /dev/null
+++ b/EjemplosBasicos/ejemplo2/ejemplo2.h
@@ -0,0 +1 @@
+#define YYSTYPE double  /*  tipos de datos de la pila de yacc */
diff --git a/EjemplosBasicos/ejemplo2/ejemplo2.y b/EjemplosBasicos/ejemplo2/ejemplo2.y
new file mode 100644
index 0000000..21cc574
--- /dev/null
+++ b/EjemplosBasicos/ejemplo2/ejemplo2.y
@@ -0,0 +1,78 @@
+/*
+ Ejemplo 2
+
+ Se ha ampliado el ejemplo 1 
+ Se permite el uso de 
+  - punto coma ";" como delimitador de expresiones, además del salto de línea
+  - signo + unario
+  - operador del resto de la división entera: %
+  - operador potencia de un número: ^ (asociativo por la derecha)
+  
+  El programa termina su ejecución cuando se teclea # al principio de la línea 
+  o pulsando Control + D
+*/
+
+
+%{
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo2.h"  
+
+%}
+
+
+%token NUMBER FIN
+%left '+' '-'   /* asociatividad a la izquierda; precedencia menor */
+%left '*' '/' '%'
+%left UNARIO /* maxima precedencia */ 
+%right '^' //aqui tiene maxima prioridad, mas que todos y ademas se pone right para que si se anidan potencias que se vayan cogiendo desde la derecha
+%%
+
+list :       /* nada: epsilon - produccion */
+        | list FIN
+        | list expr FIN  {printf("\t%.8g\n",$2);}
+        ;
+
+expr :    NUMBER        {$$ = $1;}  
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '/' expr {$$ = $1 / $3;}
+        | expr '%' expr {$$ = (int) $1 % (int) $3;} //sin int da error
+        | expr '^' expr {$$ = pow($1,$3);}
+        | '(' expr ')'  {$$ = $2;}
+        | '-' expr %prec UNARIO { $$ = -$2;}
+        | '+' expr %prec UNARIO { $$ = $2;}
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ progname=argv[0];
+ yyparse(); //esta en ejemplo2.tab.c
+}
+
+
+/* Llamada en caso de error de sintaxis de yacc */
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+/* Imprime mensajes de aviso */
+
+warning(char *s, char *t)
+{
+ fprintf(stderr,"%s: %s", progname,s);
+ if (t) fprintf(stderr," %s ",t);
+ fprintf(stderr," en la linea %d \n",lineno);
+}
diff --git a/EjemplosBasicos/ejemplo2/lexico2.l b/EjemplosBasicos/ejemplo2/lexico2.l
new file mode 100644
index 0000000..33e1f4f
--- /dev/null
+++ b/EjemplosBasicos/ejemplo2/lexico2.l
@@ -0,0 +1,26 @@
+%{
+#include "ejemplo2.h"
+#include "ejemplo2.tab.h"
+
+
+/* extern YYSTYPE yylval; */
+extern char *progname;
+extern int lineno;
+%}
+/* definicion regular */
+
+numero   [0-9]
+  	
+%%
+[ \t] 		{ ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+  {sscanf(yytext,"%lf",&yylval);
+                                    return NUMBER;}
+
+
+;       {return FIN;}
+\n      {lineno++; return FIN;}
+^#      {printf("\n Fin del programa\n"); return 0;}
+.       {return yytext[0];}
+%%
+
diff --git a/EjemplosBasicos/ejemplo3/Makefile b/EjemplosBasicos/ejemplo3/Makefile
new file mode 100644
index 0000000..fe56fd2
--- /dev/null
+++ b/EjemplosBasicos/ejemplo3/Makefile
@@ -0,0 +1,29 @@
+FUENTE = ejemplo3
+LEXICO = lexico3
+
+CC = gcc
+YFLAGS = -d 
+LFLAGS = -lfl -lm  # fl: biblioteca de flex; m: biblioteca matemática
+
+OBJS= $(FUENTE).tab.o lex.yy.o 
+
+$(FUENTE).exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe 
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h 
+	$(CC) -c lex.yy.c 
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h 
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o: $(FUENTE).tab.c  $(FUENTE).tab.h 
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros auxiliares y los objetos
+clean: 
+	rm  -f $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe
+
+
diff --git a/EjemplosBasicos/ejemplo3/ejemplo3.y b/EjemplosBasicos/ejemplo3/ejemplo3.y
new file mode 100644
index 0000000..a3824c1
--- /dev/null
+++ b/EjemplosBasicos/ejemplo3/ejemplo3.y
@@ -0,0 +1,108 @@
+/*
+ Ejemplo 3:
+
+  Se ha ampliado el ejemplo 2 para permitir asignar valores a variables simples
+  Las variables podrán ser letras minúsculas del alfabeto latino
+  Por ejemplo:
+    a = 2;
+    b = 3 * a;
+
+ Se ha incluido un mecanismo para recuperarse de un error, 
+ es decir, si hay un error sintáctico, el intérprete lo comunica pero no termina la ejecución
+ 
+ También se controla la división por cero 
+*/
+
+
+%{
+#include <stdio.h>
+#include <math.h>
+
+  double mem[26]; /* memoria para la variables `a',..., `z' */
+%}
+
+%union{             /* tipo de la pila */
+       double val;  /* valor actual */ 
+       int index;   /* indice de mem[] */
+} 
+
+%token FIN
+%token <val> NUMBER //con <val> le decimos que vamos a usar el campo val para la cosa esa del valor
+%token <index> VAR
+%type <val> expr 
+%right '=' //esto es por si pones a = 2 + 5 tiene que tener menos precedencia que todos los operadores
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'
+
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list expr FIN  {printf("\t%.8g\n",$2);}
+        | list error FIN {yyerrok;} //error es una variable de bison y yyerrok es una macro de bison
+        ;
+expr :    NUMBER 
+        | VAR { $$ = mem [$1];}
+        | VAR '=' expr { $$ = mem [$1] = $3;} //$1 es el valor del indice que se coge en el .l y asigna a ese valor $3
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '%' expr {if ($3 == 0.0) execerror("division por cero ","");
+			  else $$ = (int) $1 % (int) $3;}
+        | expr '^' expr {$$ = pow($1,$3);}
+        | expr '/' expr {if ($3 == 0.0) execerror("division por cero INUTIL ","");
+			  else $$ = $1 / $3;}
+        | '(' expr ')'  {$$ = $2;}
+        | '+' expr %prec UNARIO { $$ = +$2; }
+        | '-' expr %prec UNARIO { $$ = -$2; }
+	;
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+/* Establece un estado viable para continuar despues de un error */
+ setjmp(begin); 
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch); 
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr,"%s: %s", progname,s);
+ if (t) fprintf(stderr,"%s",t);
+ fprintf(stderr," en la linea %d \n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t); /* da el mensaje de error */
+ longjmp(begin,0); /* vuelve a un estado viable */
+}
+
+void fpecatch()     /* maneja errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo3/lexico3.l b/EjemplosBasicos/ejemplo3/lexico3.l
new file mode 100644
index 0000000..0516058
--- /dev/null
+++ b/EjemplosBasicos/ejemplo3/lexico3.l
@@ -0,0 +1,27 @@
+%{
+#include "ejemplo3.tab.h"
+
+/*extern YYSTYPE yylval;*/
+
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+
+numero   [0-9]
+letra    [a-z]
+  	
+%%
+[ \t] 		{ ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+  {sscanf(yytext,"%lf",&yylval.val);
+                                    return NUMBER;}
+
+{letra} {yylval.index=yytext[0] -'a'; return VAR;} //esto es para guardar la variable en un vector, si introducimos a, la operacion es a - a y se guarda en la posicion 0
+
+;       {return FIN;}
+\n      {lineno++; return FIN;}
+^#      {printf("\n Fin del pograma\n"); return 0;}
+.       {return yytext[0];}
+%%
+
diff --git a/EjemplosBasicos/ejemplo4/Makefile b/EjemplosBasicos/ejemplo4/Makefile
new file mode 100644
index 0000000..71ba76e
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/Makefile
@@ -0,0 +1,27 @@
+FUENTE = ejemplo4
+LEXICO = lexico4
+
+CC = gcc
+YFLAGS = -d 
+LFLAGS = -lfl -lm  # fl: biblioteca de flex; m: biblioteca matemática
+
+OBJS= $(FUENTE).tab.o lex.yy.o 
+
+$(FUENTE).exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe 
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h 
+	$(CC) -c lex.yy.c 
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h 
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o: $(FUENTE).tab.c  $(FUENTE).tab.h 
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros auxiliares y los objetos
+clean: 
+	rm  -f $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe
diff --git a/EjemplosBasicos/ejemplo4/ejemplo4.exe b/EjemplosBasicos/ejemplo4/ejemplo4.exe
new file mode 100755
index 0000000..ee0b5d7
Binary files /dev/null and b/EjemplosBasicos/ejemplo4/ejemplo4.exe differ
diff --git a/EjemplosBasicos/ejemplo4/ejemplo4.tab.c b/EjemplosBasicos/ejemplo4/ejemplo4.tab.c
new file mode 100644
index 0000000..830c9ff
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/ejemplo4.tab.c
@@ -0,0 +1,1586 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 12 "ejemplo4.y" /* yacc.c:339  */
+
+#include <stdio.h>
+#include <math.h>
+
+  double mem[26]; /* memoria para la variables `a',..., `z' */
+
+#line 73 "ejemplo4.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "ejemplo4.tab.h".  */
+#ifndef YY_YY_EJEMPLO4_TAB_H_INCLUDED
+# define YY_YY_EJEMPLO4_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIN = 258,
+    NUMBER = 259,
+    VAR = 260,
+    ASIGNACION = 261,
+    UNARIO = 262
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 19 "ejemplo4.y" /* yacc.c:355  */
+             /* tipo de la pila */
+       double val;  /* valor actual */ 
+       int index;   /* indice de mem[] */
+
+#line 126 "ejemplo4.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_EJEMPLO4_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 141 "ejemplo4.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   63
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  16
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  3
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  17
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  31
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   262
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,    11,     2,     2,
+      14,    15,     9,     7,     2,     8,     2,    10,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    13,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,    12
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    36,    36,    37,    38,    39,    41,    42,    43,    44,
+      45,    46,    47,    49,    50,    52,    53,    54
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "FIN", "NUMBER", "VAR", "ASIGNACION",
+  "'+'", "'-'", "'*'", "'/'", "'%'", "UNARIO", "'^'", "'('", "')'",
+  "$accept", "list", "expr", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,    43,    45,    42,
+      47,    37,   262,    94,    40,    41
+};
+# endif
+
+#define YYPACT_NINF -8
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-8)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      -8,    16,    -8,     0,    -8,    -8,    -2,    34,    34,    34,
+      24,    -8,    34,    -6,    -6,    36,    -8,    34,    34,    34,
+      34,    34,    34,    45,    -8,    50,    50,    -6,    -6,    -6,
+      -6
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,     3,     6,     7,     0,     0,     0,
+       0,     5,     0,    16,    17,     0,     4,     0,     0,     0,
+       0,     0,     0,     8,    15,     9,    10,    11,    14,    12,
+      13
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+      -8,    -8,    -7
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    10
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      13,    14,    15,    11,    12,    23,     0,    22,     0,     0,
+      25,    26,    27,    28,    29,    30,     2,     3,     0,     4,
+       5,     6,     0,     7,     8,     0,     0,    16,     0,     0,
+       9,    17,    18,    19,    20,    21,     0,    22,     5,     6,
+       0,     7,     8,    17,    18,    19,    20,    21,     9,    22,
+       0,    24,    17,    18,    19,    20,    21,     0,    22,    19,
+      20,    21,     0,    22
+};
+
+static const yytype_int8 yycheck[] =
+{
+       7,     8,     9,     3,     6,    12,    -1,    13,    -1,    -1,
+      17,    18,    19,    20,    21,    22,     0,     1,    -1,     3,
+       4,     5,    -1,     7,     8,    -1,    -1,     3,    -1,    -1,
+      14,     7,     8,     9,    10,    11,    -1,    13,     4,     5,
+      -1,     7,     8,     7,     8,     9,    10,    11,    14,    13,
+      -1,    15,     7,     8,     9,    10,    11,    -1,    13,     9,
+      10,    11,    -1,    13
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    17,     0,     1,     3,     4,     5,     7,     8,    14,
+      18,     3,     6,    18,    18,    18,     3,     7,     8,     9,
+      10,    11,    13,    18,    15,    18,    18,    18,    18,    18,
+      18
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    16,    17,    17,    17,    17,    18,    18,    18,    18,
+      18,    18,    18,    18,    18,    18,    18,    18
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     3,     3,     1,     1,     3,     3,
+       3,     3,     3,     3,     3,     3,     2,     2
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+#line 38 "ejemplo4.y" /* yacc.c:1646  */
+    {printf("\t%.8g\n",(yyvsp[-1].val)); mem['p'-'a']=(yyvsp[-1].val);}
+#line 1233 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 39 "ejemplo4.y" /* yacc.c:1646  */
+    {yyerrok;}
+#line 1239 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 42 "ejemplo4.y" /* yacc.c:1646  */
+    { (yyval.val) = mem [(yyvsp[0].index)];}
+#line 1245 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 43 "ejemplo4.y" /* yacc.c:1646  */
+    { (yyval.val) = mem [(yyvsp[-2].index)] = (yyvsp[0].val);}
+#line 1251 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 44 "ejemplo4.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) + (yyvsp[0].val);}
+#line 1257 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 45 "ejemplo4.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) - (yyvsp[0].val);}
+#line 1263 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 46 "ejemplo4.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) * (yyvsp[0].val);}
+#line 1269 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 47 "ejemplo4.y" /* yacc.c:1646  */
+    {if ((yyvsp[0].val) == 0.0) execerror("division por cero ","");
+			  else (yyval.val) = (int) (yyvsp[-2].val) % (int) (yyvsp[0].val);}
+#line 1276 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 49 "ejemplo4.y" /* yacc.c:1646  */
+    {(yyval.val) = pow((yyvsp[-2].val),(yyvsp[0].val));}
+#line 1282 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 50 "ejemplo4.y" /* yacc.c:1646  */
+    {if ((yyvsp[0].val) == 0.0) execerror("division por cero ","");
+			  else (yyval.val) = (yyvsp[-2].val) / (yyvsp[0].val);}
+#line 1289 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 52 "ejemplo4.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-1].val);}
+#line 1295 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 53 "ejemplo4.y" /* yacc.c:1646  */
+    { (yyval.val) = +(yyvsp[0].val); }
+#line 1301 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 54 "ejemplo4.y" /* yacc.c:1646  */
+    { (yyval.val) = -(yyvsp[0].val); }
+#line 1307 "ejemplo4.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1311 "ejemplo4.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 56 "ejemplo4.y" /* yacc.c:1906  */
+
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+/* Establece un estado viable para continuar despues de un error */
+ setjmp(begin); 
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch); 
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr,"%s: %s", progname,s);
+ if (t) fprintf(stderr,"%s",t);
+ fprintf(stderr," en la linea %d \n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t); /* da el mensaje de error */
+ longjmp(begin,0); /* vuelve a un estado viable */
+}
+
+void fpecatch()     /* maneja errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo4/ejemplo4.tab.h b/EjemplosBasicos/ejemplo4/ejemplo4.tab.h
new file mode 100644
index 0000000..e408f76
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/ejemplo4.tab.h
@@ -0,0 +1,77 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_EJEMPLO4_TAB_H_INCLUDED
+# define YY_YY_EJEMPLO4_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIN = 258,
+    NUMBER = 259,
+    VAR = 260,
+    ASIGNACION = 261,
+    UNARIO = 262
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 19 "ejemplo4.y" /* yacc.c:1909  */
+             /* tipo de la pila */
+       double val;  /* valor actual */ 
+       int index;   /* indice de mem[] */
+
+#line 67 "ejemplo4.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_EJEMPLO4_TAB_H_INCLUDED  */
diff --git a/EjemplosBasicos/ejemplo4/ejemplo4.tab.o b/EjemplosBasicos/ejemplo4/ejemplo4.tab.o
new file mode 100644
index 0000000..e49a961
Binary files /dev/null and b/EjemplosBasicos/ejemplo4/ejemplo4.tab.o differ
diff --git a/EjemplosBasicos/ejemplo4/ejemplo4.y b/EjemplosBasicos/ejemplo4/ejemplo4.y
new file mode 100644
index 0000000..0865a37
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/ejemplo4.y
@@ -0,0 +1,103 @@
+/*
+ Ejemplo 4:
+
+  Se ha modificado el ejemplo 3 para usar el operador de asignación de Pascal
+   := 
+
+  Por ejemplo
+   a := 3;
+*/
+
+
+%{
+#include <stdio.h>
+#include <math.h>
+
+  double mem[26]; /* memoria para la variables `a',..., `z' */
+%}
+
+%union{             /* tipo de la pila */
+       double val;  /* valor actual */ 
+       int index;   /* indice de mem[] */
+} 
+
+%token FIN
+%token <val> NUMBER
+%token <index> VAR
+%type <val> expr 
+%right ASIGNACION 
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'
+
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list expr FIN  {printf("\t%.8g\n",$2); mem['p'-'a']=$2;}
+        | list error FIN {yyerrok;}
+        ;
+expr :    NUMBER 
+        | VAR { $$ = mem [$1];}
+        | VAR ASIGNACION  expr { $$ = mem [$1] = $3;}
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '%' expr {if ($3 == 0.0) execerror("division por cero ","");
+			  else $$ = (int) $1 % (int) $3;}
+        | expr '^' expr {$$ = pow($1,$3);}
+        | expr '/' expr {if ($3 == 0.0) execerror("division por cero ","");
+			  else $$ = $1 / $3;}
+        | '(' expr ')'  {$$ = $2;}
+        | '+' expr %prec UNARIO { $$ = +$2; }
+        | '-' expr %prec UNARIO { $$ = -$2; }
+	;
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+/* Establece un estado viable para continuar despues de un error */
+ setjmp(begin); 
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch); 
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr,"%s: %s", progname,s);
+ if (t) fprintf(stderr,"%s",t);
+ fprintf(stderr," en la linea %d \n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t); /* da el mensaje de error */
+ longjmp(begin,0); /* vuelve a un estado viable */
+}
+
+void fpecatch()     /* maneja errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo4/lex.yy.c b/EjemplosBasicos/ejemplo4/lex.yy.c
new file mode 100644
index 0000000..7605b2a
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/lex.yy.c
@@ -0,0 +1,1796 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 9
+#define YY_END_OF_BUFFER 10
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[18] =
+    {   0,
+        0,    0,   10,    8,    1,    6,    8,    2,    8,    5,
+        3,    7,    2,    2,    2,    4,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    4,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    5,    1,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    7,    8,    1,
+        9,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,   10,   10,   10,   10,
+
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[11] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[18] =
+    {   0,
+        0,   14,   17,   19,   19,   19,   10,    6,    6,   19,
+       19,   19,    8,    7,    0,   19,   19
+    } ;
+
+static yyconst flex_int16_t yy_def[18] =
+    {   0,
+       17,    1,   17,   17,   17,   17,   17,   17,   17,   17,
+       17,   17,   17,   17,    8,   17,    0
+    } ;
+
+static yyconst flex_int16_t yy_nxt[30] =
+    {   0,
+        4,    5,    6,    4,    7,    8,    9,   10,    4,   11,
+       14,   15,   13,   13,   16,   13,   17,   12,    3,   17,
+       17,   17,   17,   17,   17,   17,   17,   17,   17
+    } ;
+
+static yyconst flex_int16_t yy_chk[30] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        8,    8,   14,   13,    9,    7,    3,    2,   17,   17,
+       17,   17,   17,   17,   17,   17,   17,   17,   17
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "lexico4.l"
+/*
+ Ejemplo 4:
+
+  Se ha modificado el ejemplo 3 para usar el operador de asignación de Pascal
+   := 
+
+  Por ejemplo
+   a := 3;
+*/
+#line 14 "lexico4.l"
+#include "ejemplo4.tab.h"
+
+/* extern YYSTYPE yylval; */
+
+extern char *progname;
+extern int lineno;
+/* definiciones regulares */
+#line 473 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 26 "lexico4.l"
+
+#line 660 "lex.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 18 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 19 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 27 "lexico4.l"
+{ ; } /* saltar los espacios y los tabuladores */
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 29 "lexico4.l"
+{sscanf(yytext,"%lf",&yylval.val);
+                                    return NUMBER;}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 32 "lexico4.l"
+{yylval.index=yytext[0] -'a'; return VAR;}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 34 "lexico4.l"
+{return ASIGNACION;}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 35 "lexico4.l"
+{return FIN;}
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 36 "lexico4.l"
+{lineno++; return FIN;}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 37 "lexico4.l"
+{printf("\nCobarde! Un ingeniero nunca descansa!\n"); return 0;}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 38 "lexico4.l"
+{return yytext[0];}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 39 "lexico4.l"
+ECHO;
+	YY_BREAK
+#line 791 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 18 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 18 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 17);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 39 "lexico4.l"
+
+
+
+
+
diff --git a/EjemplosBasicos/ejemplo4/lex.yy.o b/EjemplosBasicos/ejemplo4/lex.yy.o
new file mode 100644
index 0000000..c3d270e
Binary files /dev/null and b/EjemplosBasicos/ejemplo4/lex.yy.o differ
diff --git a/EjemplosBasicos/ejemplo4/lexico4.l b/EjemplosBasicos/ejemplo4/lexico4.l
new file mode 100644
index 0000000..13c550f
--- /dev/null
+++ b/EjemplosBasicos/ejemplo4/lexico4.l
@@ -0,0 +1,41 @@
+/*
+ Ejemplo 4:
+
+  Se ha modificado el ejemplo 3 para usar el operador de asignación de Pascal
+   := 
+
+  Por ejemplo
+   a := 3;
+*/
+
+
+
+%{
+#include "ejemplo4.tab.h"
+
+/* extern YYSTYPE yylval; */
+
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+
+numero   [0-9]
+letra    [a-z]
+  	
+%%
+[ \t] 		{ ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+  {sscanf(yytext,"%lf",&yylval.val);
+                                    return NUMBER;}
+
+{letra} {yylval.index=yytext[0] -'a'; return VAR;}
+
+:=      {return ASIGNACION;}
+;       {return FIN;}
+\n      {lineno++; return FIN;}
+^#      {printf("\nCobarde! Un ingeniero nunca descansa!\n"); return 0;}
+.       {return yytext[0];}
+%%
+
+
diff --git a/EjemplosBasicos/ejemplo5/Makefile b/EjemplosBasicos/ejemplo5/Makefile
new file mode 100644
index 0000000..336b0ff
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/Makefile
@@ -0,0 +1,36 @@
+FUENTE = ejemplo5
+LEXICO = lexico5
+
+
+CC = gcc
+YFLAGS = -d 
+LFLAGS = -lm -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o  init.o   math.o   symbol.o 
+
+$(FUENTE)3.exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
+
+init.o:  init.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c init.c
+
+symbol.o:  symbol.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c symbol.c
+
+math.o:  math.c $(FUENTE).h
+	$(CC) -c math.c
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros objetos y auxiliares
+clean: 
+	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.exe b/EjemplosBasicos/ejemplo5/ejemplo5.exe
new file mode 100755
index 0000000..57ec9ef
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/ejemplo5.exe differ
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.h b/EjemplosBasicos/ejemplo5/ejemplo5.h
new file mode 100644
index 0000000..a034e41
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/ejemplo5.h
@@ -0,0 +1,13 @@
+ /* ejemplo5.h */
+
+typedef struct Symbol { /* entrada en la tabla de simbolos */
+	               char *nombre;
+	               short tipo;  /* VAR, FUNCION, INDEFINIDA */ 
+	               union {
+		              double val;        /* si es VAR */
+		              double (*ptr)();   /* si es FUNCION */
+		             } u;
+                       struct Symbol * siguiente;
+	              } Symbol;
+
+Symbol *install(char *s, int t, double), *lookup(char *s);
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.output b/EjemplosBasicos/ejemplo5/ejemplo5.output
new file mode 100644
index 0000000..447aff7
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/ejemplo5.output
@@ -0,0 +1,564 @@
+Terminals unused in grammar
+
+   INDEFINIDA
+
+
+Estado 11 conflictos: 1 desplazamiento(s)/reducción(ones)
+
+
+Gramática
+
+    0 $accept: list $end
+
+    1 list: %empty
+    2     | list FIN
+    3     | list asgn FIN
+    4     | list expr FIN
+    5     | list error FIN
+
+    6 asgn: VAR ASIGNACION expr
+
+    7 expr: NUMBER
+    8     | VAR
+    9     | asgn
+   10     | FUNCION_PREDEFINIDA '(' expr ')'
+   11     | expr '+' expr
+   12     | expr '-' expr
+   13     | expr '*' expr
+   14     | expr '/' expr
+   15     | expr '%' expr
+   16     | expr '^' expr
+   17     | '(' expr ')'
+   18     | '-' expr
+   19     | '+' expr
+
+
+Terminales con las reglas donde aparecen
+
+$end (0) 0
+'%' (37) 15
+'(' (40) 10 17
+')' (41) 10 17
+'*' (42) 13
+'+' (43) 11 19
+'-' (45) 12 18
+'/' (47) 14
+'^' (94) 16
+error (256) 5
+FIN (258) 2 3 4 5
+NUMBER (259) 7
+VAR (260) 6 8
+INDEFINIDA (261)
+FUNCION_PREDEFINIDA (262) 10
+ASIGNACION (263) 6
+UNARIO (264)
+
+
+No terminales con las reglas donde aparecen
+
+$accept (18)
+    en la izquierda: 0
+list (19)
+    en la izquierda: 1 2 3 4 5, en la derecha: 0 2 3 4 5
+asgn (20)
+    en la izquierda: 6, en la derecha: 3 9
+expr (21)
+    en la izquierda: 7 8 9 10 11 12 13 14 15 16 17 18 19, en la derecha:
+    4 6 10 11 12 13 14 15 16 17 18 19
+
+
+State 0
+
+    0 $accept: . list $end
+
+    $default  reduce usando la regla 1 (list)
+
+    list  ir al estado 1
+
+
+State 1
+
+    0 $accept: list . $end
+    2 list: list . FIN
+    3     | list . asgn FIN
+    4     | list . expr FIN
+    5     | list . error FIN
+
+    $end                 desplazar e ir al estado 2
+    error                desplazar e ir al estado 3
+    FIN                  desplazar e ir al estado 4
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 11
+    expr  ir al estado 12
+
+
+State 2
+
+    0 $accept: list $end .
+
+    $default  aceptar
+
+
+State 3
+
+    5 list: list error . FIN
+
+    FIN  desplazar e ir al estado 13
+
+
+State 4
+
+    2 list: list FIN .
+
+    $default  reduce usando la regla 2 (list)
+
+
+State 5
+
+    7 expr: NUMBER .
+
+    $default  reduce usando la regla 7 (expr)
+
+
+State 6
+
+    6 asgn: VAR . ASIGNACION expr
+    8 expr: VAR .
+
+    ASIGNACION  desplazar e ir al estado 14
+
+    $default  reduce usando la regla 8 (expr)
+
+
+State 7
+
+   10 expr: FUNCION_PREDEFINIDA . '(' expr ')'
+
+    '('  desplazar e ir al estado 15
+
+
+State 8
+
+   19 expr: '+' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 17
+
+
+State 9
+
+   18 expr: '-' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 18
+
+
+State 10
+
+   17 expr: '(' . expr ')'
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 19
+
+
+State 11
+
+    3 list: list asgn . FIN
+    9 expr: asgn .
+
+    FIN  desplazar e ir al estado 20
+
+    FIN       [reduce usando la regla 9 (expr)]
+    $default  reduce usando la regla 9 (expr)
+
+
+State 12
+
+    4 list: list expr . FIN
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    FIN  desplazar e ir al estado 21
+    '+'  desplazar e ir al estado 22
+    '-'  desplazar e ir al estado 23
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+
+
+State 13
+
+    5 list: list error FIN .
+
+    $default  reduce usando la regla 5 (list)
+
+
+State 14
+
+    6 asgn: VAR ASIGNACION . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 28
+
+
+State 15
+
+   10 expr: FUNCION_PREDEFINIDA '(' . expr ')'
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 29
+
+
+State 16
+
+    9 expr: asgn .
+
+    $default  reduce usando la regla 9 (expr)
+
+
+State 17
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+   19     | '+' expr .
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 19 (expr)
+
+
+State 18
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+   18     | '-' expr .
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 18 (expr)
+
+
+State 19
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+   17     | '(' expr . ')'
+
+    '+'  desplazar e ir al estado 22
+    '-'  desplazar e ir al estado 23
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+    ')'  desplazar e ir al estado 30
+
+
+State 20
+
+    3 list: list asgn FIN .
+
+    $default  reduce usando la regla 3 (list)
+
+
+State 21
+
+    4 list: list expr FIN .
+
+    $default  reduce usando la regla 4 (list)
+
+
+State 22
+
+   11 expr: expr '+' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 31
+
+
+State 23
+
+   12 expr: expr '-' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 32
+
+
+State 24
+
+   13 expr: expr '*' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 33
+
+
+State 25
+
+   14 expr: expr '/' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 34
+
+
+State 26
+
+   15 expr: expr '%' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 35
+
+
+State 27
+
+   16 expr: expr '^' . expr
+
+    NUMBER               desplazar e ir al estado 5
+    VAR                  desplazar e ir al estado 6
+    FUNCION_PREDEFINIDA  desplazar e ir al estado 7
+    '+'                  desplazar e ir al estado 8
+    '-'                  desplazar e ir al estado 9
+    '('                  desplazar e ir al estado 10
+
+    asgn  ir al estado 16
+    expr  ir al estado 36
+
+
+State 28
+
+    6 asgn: VAR ASIGNACION expr .
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '+'  desplazar e ir al estado 22
+    '-'  desplazar e ir al estado 23
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 6 (asgn)
+
+
+State 29
+
+   10 expr: FUNCION_PREDEFINIDA '(' expr . ')'
+   11     | expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '+'  desplazar e ir al estado 22
+    '-'  desplazar e ir al estado 23
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+    ')'  desplazar e ir al estado 37
+
+
+State 30
+
+   17 expr: '(' expr ')' .
+
+    $default  reduce usando la regla 17 (expr)
+
+
+State 31
+
+   11 expr: expr . '+' expr
+   11     | expr '+' expr .
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 11 (expr)
+
+
+State 32
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   12     | expr '-' expr .
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '*'  desplazar e ir al estado 24
+    '/'  desplazar e ir al estado 25
+    '%'  desplazar e ir al estado 26
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 12 (expr)
+
+
+State 33
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   13     | expr '*' expr .
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 13 (expr)
+
+
+State 34
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   14     | expr '/' expr .
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 14 (expr)
+
+
+State 35
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   15     | expr '%' expr .
+   16     | expr . '^' expr
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 15 (expr)
+
+
+State 36
+
+   11 expr: expr . '+' expr
+   12     | expr . '-' expr
+   13     | expr . '*' expr
+   14     | expr . '/' expr
+   15     | expr . '%' expr
+   16     | expr . '^' expr
+   16     | expr '^' expr .
+
+    '^'  desplazar e ir al estado 27
+
+    $default  reduce usando la regla 16 (expr)
+
+
+State 37
+
+   10 expr: FUNCION_PREDEFINIDA '(' expr ')' .
+
+    $default  reduce usando la regla 10 (expr)
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.tab.c b/EjemplosBasicos/ejemplo5/ejemplo5.tab.c
new file mode 100644
index 0000000..b77654d
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/ejemplo5.tab.c
@@ -0,0 +1,1601 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 26 "ejemplo5.y" /* yacc.c:339  */
+
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo5.h"
+
+#line 73 "ejemplo5.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIN = 258,
+    NUMBER = 259,
+    VAR = 260,
+    INDEFINIDA = 261,
+    FUNCION_PREDEFINIDA = 262,
+    ASIGNACION = 263,
+    UNARIO = 264
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 33 "ejemplo5.y" /* yacc.c:355  */
+
+       double val;  /* valor actual */ 
+       Symbol *sym; /* puntero a la tabla de simbolos */
+      
+
+#line 126 "ejemplo5.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+
+
+/* Copy the second part of user declarations.  */
+
+#line 141 "ejemplo5.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   75
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  18
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  4
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  20
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  38
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   264
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,    13,     2,     2,
+      16,    17,    11,     9,     2,    10,     2,    12,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    15,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,    14
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    49,    49,    50,    51,    52,    53,    56,    59,    60,
+      63,    64,    65,    66,    67,    68,    70,    72,    73,    74,
+      75
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "FIN", "NUMBER", "VAR", "INDEFINIDA",
+  "FUNCION_PREDEFINIDA", "ASIGNACION", "'+'", "'-'", "'*'", "'/'", "'%'",
+  "UNARIO", "'^'", "'('", "')'", "$accept", "list", "asgn", "expr", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,    43,
+      45,    42,    47,    37,   264,    94,    40,    41
+};
+# endif
+
+#define YYPACT_NINF -12
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-12)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+     -12,    20,   -12,     0,   -12,   -12,    -4,   -11,    40,    40,
+      40,     8,    28,   -12,    40,    40,   -12,    -2,    -2,    42,
+     -12,   -12,    40,    40,    40,    40,    40,    40,    60,    51,
+     -12,    -3,    -3,    -2,    -2,    -2,    -2,   -12
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,     3,     8,     9,     0,     0,     0,
+       0,    10,     0,     6,     0,     0,    10,    20,    19,     0,
+       4,     5,     0,     0,     0,     0,     0,     0,     7,     0,
+      18,    12,    13,    14,    15,    16,    17,    11
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -12,   -12,    21,    -8
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    16,    12
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      17,    18,    19,    13,    14,    15,    28,    29,    24,    25,
+      26,    20,    27,    27,    31,    32,    33,    34,    35,    36,
+       2,     3,    11,     4,     5,     6,     0,     7,     0,     8,
+       9,    21,     0,     0,     0,     0,    10,    22,    23,    24,
+      25,    26,     0,    27,     5,     6,     0,     7,     0,     8,
+       9,    22,    23,    24,    25,    26,    10,    27,     0,    30,
+      22,    23,    24,    25,    26,     0,    27,     0,    37,    22,
+      23,    24,    25,    26,     0,    27
+};
+
+static const yytype_int8 yycheck[] =
+{
+       8,     9,    10,     3,     8,    16,    14,    15,    11,    12,
+      13,     3,    15,    15,    22,    23,    24,    25,    26,    27,
+       0,     1,     1,     3,     4,     5,    -1,     7,    -1,     9,
+      10,     3,    -1,    -1,    -1,    -1,    16,     9,    10,    11,
+      12,    13,    -1,    15,     4,     5,    -1,     7,    -1,     9,
+      10,     9,    10,    11,    12,    13,    16,    15,    -1,    17,
+       9,    10,    11,    12,    13,    -1,    15,    -1,    17,     9,
+      10,    11,    12,    13,    -1,    15
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    19,     0,     1,     3,     4,     5,     7,     9,    10,
+      16,    20,    21,     3,     8,    16,    20,    21,    21,    21,
+       3,     3,     9,    10,    11,    12,    13,    15,    21,    21,
+      17,    21,    21,    21,    21,    21,    21,    17
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    18,    19,    19,    19,    19,    19,    20,    21,    21,
+      21,    21,    21,    21,    21,    21,    21,    21,    21,    21,
+      21
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     3,     3,     3,     3,     1,     1,
+       1,     4,     3,     3,     3,     3,     3,     3,     3,     2,
+       2
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 5:
+#line 52 "ejemplo5.y" /* yacc.c:1646  */
+    {printf("\t%.8g\n",(yyvsp[-1].val));}
+#line 1238 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 53 "ejemplo5.y" /* yacc.c:1646  */
+    {yyerrok;}
+#line 1244 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 56 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].sym)->u.val=(yyvsp[0].val); (yyvsp[-2].sym)->tipo = VAR;}
+#line 1250 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 60 "ejemplo5.y" /* yacc.c:1646  */
+    { if ((yyvsp[0].sym)->tipo ==  INDEFINIDA) 
+		  execerror(" variable no definida ",(yyvsp[0].sym)->nombre);
+                 else (yyval.val) = (yyvsp[0].sym)->u.val;}
+#line 1258 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 64 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (*((yyvsp[-3].sym)->u.ptr))((yyvsp[-1].val));}
+#line 1264 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 65 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) + (yyvsp[0].val);}
+#line 1270 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 66 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) - (yyvsp[0].val);}
+#line 1276 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 67 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-2].val) * (yyvsp[0].val);}
+#line 1282 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 68 "ejemplo5.y" /* yacc.c:1646  */
+    {if ((yyvsp[0].val) == 0.0) execerror(" division por cero ","");
+			  else (yyval.val) = (yyvsp[-2].val) / (yyvsp[0].val);}
+#line 1289 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 70 "ejemplo5.y" /* yacc.c:1646  */
+    {if ((yyvsp[0].val) == 0.0) execerror("division por cero ","");
+			  else (yyval.val) = (int) (yyvsp[-2].val) % (int) (yyvsp[0].val);}
+#line 1296 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 72 "ejemplo5.y" /* yacc.c:1646  */
+    { (yyval.val) = pow((yyvsp[-2].val),(yyvsp[0].val));}
+#line 1302 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 73 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = (yyvsp[-1].val);}
+#line 1308 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 74 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = -(yyvsp[0].val);}
+#line 1314 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 75 "ejemplo5.y" /* yacc.c:1646  */
+    {(yyval.val) = +(yyvsp[0].val);}
+#line 1320 "ejemplo5.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1324 "ejemplo5.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 78 "ejemplo5.y" /* yacc.c:1906  */
+
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+ init(); /* Inicializacion de la tabla de simbolos */
+
+/* Establece un estado viable para continuar despues de un error*/
+ setjmp(begin);
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch);
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.tab.h b/EjemplosBasicos/ejemplo5/ejemplo5.tab.h
new file mode 100644
index 0000000..cbf1ba1
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/ejemplo5.tab.h
@@ -0,0 +1,80 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_EJEMPLO5_TAB_H_INCLUDED
+# define YY_YY_EJEMPLO5_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    FIN = 258,
+    NUMBER = 259,
+    VAR = 260,
+    INDEFINIDA = 261,
+    FUNCION_PREDEFINIDA = 262,
+    ASIGNACION = 263,
+    UNARIO = 264
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 33 "ejemplo5.y" /* yacc.c:1909  */
+
+       double val;  /* valor actual */ 
+       Symbol *sym; /* puntero a la tabla de simbolos */
+      
+
+#line 70 "ejemplo5.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_EJEMPLO5_TAB_H_INCLUDED  */
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.tab.o b/EjemplosBasicos/ejemplo5/ejemplo5.tab.o
new file mode 100644
index 0000000..b987ae4
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/ejemplo5.tab.o differ
diff --git a/EjemplosBasicos/ejemplo5/ejemplo5.y b/EjemplosBasicos/ejemplo5/ejemplo5.y
new file mode 100644
index 0000000..2a33aed
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/ejemplo5.y
@@ -0,0 +1,128 @@
+/* 
+  Ejemplo 5
+  
+   Se ha ampliado el ejemplo 4 
+   
+   Permite que una variable pueda ser un identificador que empiece por una letra y que pueda ir seguida de letras o dígitos.
+
+   Los identificadores se almacenan en una tabla de símbolos (lista simplemente encadenada)
+
+   Hay constantes predefinidas
+   	                    "PI",    3.14159265358979323846
+	                    "E",     2.71828182845904523536
+	                    "GAMMA", 0.57721566490153286060
+	                    "DEG",  57.29577951308232087680
+	                    "PHI",   1.61803398874989484820
+   Pero permite cambiar el valor de una constante
+   PI := 3.14
+   PI := 0.0
+   
+   También permite funciones predefinidas con un argumento:
+   	sin, cos, atan, log, Log10,  exp, sqrt, int,  abs
+   	
+   	
+   	
+*/
+%{
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo5.h"
+%}
+
+%union{
+       double val;  /* valor actual */ 
+       Symbol *sym; /* puntero a la tabla de simbolos */
+      }
+
+%token FIN
+%token <val> NUMBER 
+%token <sym> VAR INDEFINIDA FUNCION_PREDEFINIDA 
+%type <val> expr asgn
+%right ASIGNACION
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list asgn FIN  
+        | list expr FIN  {printf("\t%.8g\n",$2);}
+        | list error FIN {yyerrok;}
+        ; 
+
+asgn :    VAR ASIGNACION expr {$$ = $1->u.val=$3; $1->tipo = VAR;} //le asigna el valor de $3 al campo val de $1 y despues se asigna a asgn por si hay asignacion multiple
+	;
+
+expr :    NUMBER 
+        | VAR { if ($1->tipo ==  INDEFINIDA) 
+		  execerror(" variable no definida ",$1->nombre);
+                 else $$ = $1->u.val;}
+        | asgn //esta regla hace falta porque sino peta con las asinaciones multiples
+        | FUNCION_PREDEFINIDA '(' expr ')' {$$ = (*($1->u.ptr))($3);} 
+        //el puntero ese chungo es para ejecutar la funcion predefinida, por ejemplo el seno, y entrar al valor y el $3 es el parametro que se le pasa
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '/' expr {if ($3 == 0.0) execerror(" division por cero ","");
+			  else $$ = $1 / $3;}   
+        | expr '%' expr {if ($3 == 0.0) execerror("division por cero ","");
+			  else $$ = (int) $1 % (int) $3;}
+        | expr '^' expr { $$ = pow($1,$3);}
+        | '(' expr ')'  {$$ = $2;}
+        | '-' expr %prec UNARIO {$$ = -$2;}  
+        | '+' expr %prec UNARIO {$$ = +$2;} 
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+ init(); /* Inicializacion de la tabla de simbolos */
+
+/* Establece un estado viable para continuar despues de un error*/
+ setjmp(begin);
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch);
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo5/init.c b/EjemplosBasicos/ejemplo5/init.c
new file mode 100644
index 0000000..ec15817
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/init.c
@@ -0,0 +1,65 @@
+/* init.c */
+#include "ejemplo5.h"
+#include "ejemplo5.tab.h"
+#include <math.h>
+
+/* Prototipo de una nueva funcion matematica */
+extern double integer(double x);
+/* Prototipos de funciones matematicas que "controlan" posibles errores" */
+extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x);
+
+/* Constantes predefinidas */
+static struct{
+              char *nombre;
+	      double cval;
+	      } consts[] = {
+	                    "PI",    3.14159265358979323846,
+	                    "E",     2.71828182845904523536,
+	                    "GAMMA", 0.57721566490153286060,
+	                    "DEG",  57.29577951308232087680,
+	                    "PHI",   1.61803398874989484820,
+	                    0,       0
+	                   };
+
+/* Funciones predefinidas */ 
+static struct {    
+	       char *nombre;
+	       double (*func)();
+              } funciones [] = {
+	                       "sin",   sin,
+		               "cos",   cos,
+		               "atan",  atan,
+		               "log",   Log,
+		               "log10", Log10,
+		               "exp",   Exp,
+		               "sqrt",  Sqrt,
+		               "int",   integer,
+		               "abs",   fabs,
+		               0,       0
+		              };
+
+/* Instalacion de las constantes y de las funciones predefinidas 
+  en la tabla de simbolos */
+
+/************************************************************************/
+/** Nombre: init                                                       **/
+/** Labor que desarrolla: Inserta  en la tabla de simbolos las         **/ 
+/**        constantes y las funciones  que se encuentran en las        **/
+/**        variables globales "consts" y "funciones"                   **/ 
+/** Tipo de resultado: entero "int" (tipo por defecto)                 **/
+/** Parametros: Ninguno.                                               **/
+/************************************************************************/
+init()
+{
+ int i;
+ Symbol *s;
+
+ for (i=0; consts[i].nombre; i++) //la segunda condicion del bucle busca nombres, si hay nombre es distinto de 0 y es true, si encuentra un 0 es false y ya se sale
+       install(consts[i].nombre,VAR,consts[i].cval);
+
+ for (i=0; funciones[i].nombre; i++)
+     {
+      s=install(funciones[i].nombre,FUNCION_PREDEFINIDA,0.0);
+      s->u.ptr=funciones[i].func;
+     }
+}
diff --git a/EjemplosBasicos/ejemplo5/init.o b/EjemplosBasicos/ejemplo5/init.o
new file mode 100644
index 0000000..f0934f8
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/init.o differ
diff --git a/EjemplosBasicos/ejemplo5/lex.yy.c b/EjemplosBasicos/ejemplo5/lex.yy.c
new file mode 100644
index 0000000..61c8273
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/lex.yy.c
@@ -0,0 +1,1785 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 9
+#define YY_END_OF_BUFFER 10
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[19] =
+    {   0,
+        0,    0,   10,    8,    1,    7,    8,    2,    8,    6,
+        3,    5,    2,    2,    2,    4,    3,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    4,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    5,    1,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    7,    8,    1,
+        9,    1,    1,    1,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+        1,    1,    1,    1,    1,    1,   10,   10,   10,   10,
+
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
+       10,   10,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[11] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[19] =
+    {   0,
+        0,   16,   19,   21,   21,   21,   12,    6,    7,   21,
+        7,   21,    9,    8,    0,   21,    0,   21
+    } ;
+
+static yyconst flex_int16_t yy_def[19] =
+    {   0,
+       18,    1,   18,   18,   18,   18,   18,   18,   18,   18,
+       18,   18,   18,   18,    8,   18,   11,    0
+    } ;
+
+static yyconst flex_int16_t yy_nxt[32] =
+    {   0,
+        4,    5,    6,    4,    7,    8,    9,   10,    4,   11,
+       14,   15,   17,   13,   13,   16,   17,   13,   18,   12,
+        3,   18,   18,   18,   18,   18,   18,   18,   18,   18,
+       18
+    } ;
+
+static yyconst flex_int16_t yy_chk[32] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        8,    8,   11,   14,   13,    9,   11,    7,    3,    2,
+       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
+       18
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "lexico5.l"
+#line 2 "lexico5.l"
+#include "ejemplo5.h"
+#include "ejemplo5.tab.h"
+
+extern char *progname;
+extern int lineno;
+/* definiciones regulares */
+#line 463 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 13 "lexico5.l"
+
+#line 650 "lex.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 19 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 21 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 14 "lexico5.l"
+{ ; } /* saltar los espacios y los tabuladores */
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 16 "lexico5.l"
+{ sscanf(yytext,"%lf",&yylval.val); 
+				    return NUMBER;}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 19 "lexico5.l"
+{ Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 25 "lexico5.l"
+{return ASIGNACION;}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 26 "lexico5.l"
+{ system("eject"); return 0;}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 27 "lexico5.l"
+{return FIN ;} 
+	YY_BREAK
+case 7:
+/* rule 7 can match eol */
+YY_RULE_SETUP
+#line 28 "lexico5.l"
+{lineno++; return FIN;} 
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 29 "lexico5.l"
+{return yytext[0];}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 30 "lexico5.l"
+ECHO;
+	YY_BREAK
+#line 785 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 19 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 19 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 18);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 30 "lexico5.l"
diff --git a/EjemplosBasicos/ejemplo5/lex.yy.o b/EjemplosBasicos/ejemplo5/lex.yy.o
new file mode 100644
index 0000000..60a0986
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/lex.yy.o differ
diff --git a/EjemplosBasicos/ejemplo5/lexico5.l b/EjemplosBasicos/ejemplo5/lexico5.l
new file mode 100644
index 0000000..fa5d489
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/lexico5.l
@@ -0,0 +1,29 @@
+%{
+#include "ejemplo5.h"
+#include "ejemplo5.tab.h"
+
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+numero        [0-9]
+letra         [a-zA-Z]
+identificador {letra}({letra}|{numero})*
+
+%%
+[ \t] { ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+ { sscanf(yytext,"%lf",&yylval.val); 
+				    return NUMBER;}
+
+{identificador} { Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+
+:=      {return ASIGNACION;}
+^#      { printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+;       {return FIN ;} 
+\n      {lineno++; return FIN;} 
+.       {return yytext[0];}
diff --git a/EjemplosBasicos/ejemplo5/math.c b/EjemplosBasicos/ejemplo5/math.c
new file mode 100644
index 0000000..c0816aa
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/math.c
@@ -0,0 +1,130 @@
+/* math.c */
+#include <math.h>
+#include <errno.h>
+
+/*  Referencia a la variable global que indica los codigos 
+   de los errores generados por las funciones matematicas */
+extern int errno;
+
+/* Prototipo de la funcion que comprueba errores matematicos **/
+double errcheck(double d, char *s);
+
+/*****************************************************************/
+/** Nombre: Log                                                 **/
+/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo neperiano                   **/
+/*****************************************************************/
+double Log(double x)
+{
+ return errcheck(log(x),"logaritmo neperiano");
+ }
+
+/*****************************************************************/
+/** Nombre: Log10                                               **/
+/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo decimal                     **/
+/*****************************************************************/
+double Log10(double x)
+{
+ return errcheck(log10(x),"logaritmo decimal");
+}
+
+/*****************************************************************/
+/** Nombre: Exp                                                 **/
+/** Labor que desarrolla: calcula la exponencial de un numero   **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion exponencial                           **/
+/*****************************************************************/
+double Exp(double x)
+{
+ return errcheck(exp(x),"exponencial");
+}
+
+/*****************************************************************/
+/** Nombre: Sqrt                                                **/
+/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion raiz cuadrada.                        **/
+/*****************************************************************/
+double Sqrt(double x)
+{
+ return errcheck(sqrt(x),"raiz cuadrada");
+}
+
+/*****************************************************************/
+/** Nombre: integer                                             **/
+/** Labor que desarrolla: calcula la parte entera de un numero  **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            calcular la parte entera.                        **/
+/*****************************************************************/
+
+double integer(double x)
+{
+ return  (double) (long) x;
+}
+
+/* revision del resultado de la llamada a una funcion */
+/*****************************************************************/
+/** Nombre: errcheck                                            **/
+/** Labor que desarrolla: comprueba si se ha producido un error **/
+/**       al realizar la evaluacion matematica del primer       **/
+/**       parametro. Si no hay error, entonces devuelve el      **/
+/**       primer parametro; en caso contrario muestra el error  **/ 
+/**       producido.                                            **/
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: d                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: almacenar el valor obtenido al aplicar una      **/
+/**            funcion matematica                               **/
+/**  Nombre: s                                                  **/
+/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
+/**     Mision: indica el nombre de la funcion que se ha        **/
+/**       utilizado para calcular el valor del primer parametro.**/
+/*****************************************************************/
+double errcheck(double d, char *s)
+{
+ if (errno==EDOM)
+    {
+     errno=0; /* Desactiva el error */
+     execerror(s," argumento fuera de dominio ");
+    }
+   else if (errno==ERANGE)
+           {
+            errno=0; /* Desactiva el error */
+            execerror(s," resultado fuera de rango ");
+           }
+ return d;
+}
diff --git a/EjemplosBasicos/ejemplo5/math.o b/EjemplosBasicos/ejemplo5/math.o
new file mode 100644
index 0000000..8c0f53d
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/math.o differ
diff --git a/EjemplosBasicos/ejemplo5/symbol.c b/EjemplosBasicos/ejemplo5/symbol.c
new file mode 100644
index 0000000..628b6d1
--- /dev/null
+++ b/EjemplosBasicos/ejemplo5/symbol.c
@@ -0,0 +1,88 @@
+/* symbol.c */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "ejemplo5.h"
+#include "ejemplo5.tab.h" /* Se genera al ejecutar yacc -d hoc3.y */
+
+/*  prototipo de la funcin que controla la reserva de memoria */
+char *emalloc(unsigned n);
+
+/* Tabla de simbolos: lista simplemente encadenada */
+static Symbol *symlist=0; 
+
+/**********************************************************************/
+/** Nombre: lookup                                                   **/
+/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
+/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
+/**        a la palabra; en caso contrario, devuelve NULL.           **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
+/** Parametros:                                                      **/ 
+/**  Nombre: s                                                       **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
+/**     Mision: suministra el nombre de la palabra buscada.          **/
+/**********************************************************************/
+
+Symbol *lookup (char *s) 
+{
+	Symbol *sp;
+
+	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
+		if (strcmp(sp->nombre,s)==0) return sp;
+	return 0;
+}
+
+/************************************************************************/
+/** Nombre: install                                                    **/
+/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
+/**        indicando el token que le corresponde y su valor inicial.   **/
+/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
+/** Parametros:                                                        **/ 
+/**  Nombre: s                                                         **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
+/**     Mision: suministra el nombre de la palabra a insertar.         **/
+/**  Nombre: t                                                         **/
+/**	Tipo:   entero "int"                                           **/
+/**     Mision: indica el token de la palabra.                         **/
+/**  Nombre: d                                                         **/
+/**	Tipo:   real de doble precision "double"                       **/
+/**     Mision: suministra un valor inicial.                           **/
+/************************************************************************/
+
+Symbol *install(char *s, int t, double d)
+{
+ Symbol *sp;
+ char *emalloc();
+
+ sp=(Symbol *) emalloc(sizeof(Symbol));
+ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
+ strcpy(sp->nombre,s);
+ sp->tipo=t;
+ sp->u.val=d;
+ sp->siguiente=symlist;
+ symlist=sp;
+ return sp;
+}
+
+/************************************************************************/
+/** Nombre: emalloc                                                    **/
+/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
+/**        se producen errores.                                        **/
+/**        Devuelve un puntero a la memoria reservada.                 **/
+/** Tipo de resultado: Puntero a caracter  "char *"                    **/
+/** Parametros:                                                        **/ 
+/**  Nombre: n                                                         **/
+/**	Tipo:   entero sin signo "unsigned"                            **/
+/**     Mision: indica la cantidad de bytes que se deben reservar      **/
+/************************************************************************/
+
+char *emalloc(unsigned n)
+{
+	char *p;  
+	p = malloc(n);
+	if (p==0) execerror("\nFalta memoria\n",(char *)0);
+	return p;
+}
+
diff --git a/EjemplosBasicos/ejemplo5/symbol.o b/EjemplosBasicos/ejemplo5/symbol.o
new file mode 100644
index 0000000..5368a22
Binary files /dev/null and b/EjemplosBasicos/ejemplo5/symbol.o differ
diff --git a/EjemplosBasicos/ejemplo6/Makefile b/EjemplosBasicos/ejemplo6/Makefile
new file mode 100644
index 0000000..fe6a129
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/Makefile
@@ -0,0 +1,36 @@
+FUENTE = ejemplo6
+LEXICO = lexico6
+
+
+CC = gcc
+YFLAGS = -d -v 
+LFLAGS = -lm -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o  init6.o   math6.o   symbol6.o 
+
+$(FUENTE)3.exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
+
+init6.o:  init6.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c init6.c
+
+symbol6.o:  symbol6.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c symbol6.c
+
+math6.o:  math6.c $(FUENTE).h
+	$(CC) -c math6.c
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros objetos y auxiliares
+clean: 
+	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe  $(FUENTE).output
diff --git a/EjemplosBasicos/ejemplo6/ejemplo6.h b/EjemplosBasicos/ejemplo6/ejemplo6.h
new file mode 100644
index 0000000..e993427
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/ejemplo6.h
@@ -0,0 +1,11 @@
+typedef struct Symbol { /* entrada en la tabla de simbolos */
+	               char *nombre;
+	               short tipo;  /* VAR, FUNCION, INDEFINIDA */ 
+	               union {
+		              double val;        /* si es VAR */
+		              double (*ptr)();   /* si es FUNCION */
+		             } u;
+                       struct Symbol * siguiente;
+	              } Symbol;
+
+Symbol *install(char *s, int t, double d), *lookup(char *);
diff --git a/EjemplosBasicos/ejemplo6/ejemplo6.y b/EjemplosBasicos/ejemplo6/ejemplo6.y
new file mode 100644
index 0000000..0ca73c3
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/ejemplo6.y
@@ -0,0 +1,123 @@
+/*
+
+ Ejemplo 6
+ 
+ Ha modificado el ejemplo 5 para evitar que se modifique el valor de una constante predefinida
+
+También permite una función predefinida con dos argumentos:
+ atan2(x,y)
+ 
+ y con cero argumentos
+ azar()
+ 	                      
+ Además, las funciones predefinidas se ha puesto en castellano:
+ 	 seno, coseno, atan, log, log10, exp, raiz, entero, abs
+*/
+
+%{
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo6.h"
+%}
+
+%union{
+       double val;  /* valor actual */ 
+       Symbol *sym; /* puntero a la tabla de simbolos */
+}
+
+%token FIN
+%token <val> NUMBER 
+%token <sym> VAR INDEFINIDA FUNCION0_PREDEFINIDA CONSTANTE FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA
+%type <val> expr asgn
+%right ASIGNACION
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list asgn FIN  
+        | list expr FIN  {printf("\t%.8g\n",$2);}
+        | list error FIN {yyerrok;}
+        ; 
+
+asgn :    VAR ASIGNACION expr {$$ = $1->u.val=$3; $1->tipo = VAR;}
+        | CONSTANTE ASIGNACION expr 
+           {execerror(" NO se pueden asignar datos a constantes ",$1->nombre);}
+	;
+
+expr :    NUMBER 
+        | VAR { if ($1->tipo ==  INDEFINIDA) 
+		  execerror(" variable no definida ",$1->nombre);
+                 else $$ = $1->u.val;}
+        | CONSTANTE  {$$ = $1->u.val;}
+        | asgn
+        | FUNCION0_PREDEFINIDA '(' ')'               {$$ = (*($1->u.ptr))();}
+        | FUNCION1_PREDEFINIDA '(' expr ')' 	     {$$ = (*($1->u.ptr))($3);}
+        | FUNCION2_PREDEFINIDA '(' expr ',' expr ')' {$$=(*($1->u.ptr))($3,$5);}
+        | expr '+' expr {$$ = $1 + $3;}
+        | expr '-' expr {$$ = $1 - $3;}
+        | expr '*' expr {$$ = $1 * $3;}
+        | expr '/' expr {if ($3 == 0.0) execerror(" division por cero ","");
+			  else $$ = $1 / $3;}   
+        | expr '%' expr {if ($3 == 0.0) execerror("division por cero ","");
+			  else $$ = (int) $1 % (int) $3;}
+        | expr '^' expr { $$ = pow($1,$3);}
+        | '(' expr ')'  {$$ = $2;}
+        | '-' expr %prec UNARIO {$$ = -$2;}  
+        | '+' expr %prec UNARIO {$$ = +$2;} 
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+ init(); /* Inicializacion de la tabla de simbolos */
+
+/* Establece un estado viable para continuar despues de un error*/
+ setjmp(begin);
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch);
+
+ yyparse();
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(char *s,char *t) /* recuperacion de errores durante la ejecucion */
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo6/init6.c b/EjemplosBasicos/ejemplo6/init6.c
new file mode 100644
index 0000000..4f3e4ae
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/init6.c
@@ -0,0 +1,85 @@
+#include <math.h>
+
+#include "ejemplo6.h"
+#include "ejemplo6.tab.h"
+
+
+/* Prototipo de una nueva funcion matematica */
+extern double integer(double x), Azar();
+/* Prototipos de funciones matematicas que "controlan" posibles errores" */
+extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x),
+              Atan2(double x, double y);
+
+/* Constantes predefinidas */
+static struct{
+              char *nombre;
+	      double cval;
+	      } consts[] = {
+	                    "PI",    3.14159265358979323846,
+	                    "E",     2.71828182845904523536,
+	                    "GAMMA", 0.57721566490153286060,
+	                    "DEG",  57.29577951308232087680,
+	                    "PHI",   1.61803398874989484820,
+	                    0,       0
+	                   };
+
+/* Funciones predefinidas */ 
+static struct {     
+	       char *nombre;
+	       double (*func)();
+              } funciones0[] =  {
+                          	 "azar",  Azar,
+		               	  0,       0
+		              	},
+                funciones1 [] = {
+	                       	 "seno",   sin,
+		                 "coseno", cos,
+		                 "atan",   atan,
+		                 "log",    Log,
+		                 "log10",  Log10,
+		                 "exp",    Exp,
+		                 "raiz",   Sqrt,
+		                 "entero", integer,
+		                 "abs",    fabs,
+		                 0,       0
+		              	},
+                funciones2[] = {
+                                "atan2", Atan2,
+		                0,       0
+		              	};
+
+/***************************************************************************/
+/** Nombre: init                                                          **/
+/** Labor que desarrolla: Inserta  en la tabla de simbolos las            **/ 
+/**        constantes y las funciones  que se encuentran en las           **/
+/**        variables globales "consts,funciones0,funciones1 y funciones2" **/ 
+/** Tipo de resultado: entero "int" (tipo por defecto)                    **/
+/** Parametros: Ninguno.                                                  **/
+/***************************************************************************/
+init()
+{
+ int i;
+ Symbol *s;
+
+ for (i=0; consts[i].nombre; i++)
+       install(consts[i].nombre,CONSTANTE,consts[i].cval);
+
+ for (i=0; funciones0[i].nombre; i++)
+     {
+      s=install(funciones0[i].nombre,FUNCION0_PREDEFINIDA,0.0);
+      s->u.ptr=funciones0[i].func;
+     }
+
+ for (i=0; funciones1[i].nombre; i++)
+     {
+      s=install(funciones1[i].nombre,FUNCION1_PREDEFINIDA,0.0);
+      s->u.ptr=funciones1[i].func;
+     }
+
+ for (i=0; funciones2[i].nombre; i++)
+     {
+      s=install(funciones2[i].nombre,FUNCION2_PREDEFINIDA,0.0);
+      s->u.ptr=funciones2[i].func;
+     }
+
+}
diff --git a/EjemplosBasicos/ejemplo6/lexico6.l b/EjemplosBasicos/ejemplo6/lexico6.l
new file mode 100644
index 0000000..334159f
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/lexico6.l
@@ -0,0 +1,67 @@
+/*
+
+ Permite ejecutar un comando del shell
+ Por ejemplo
+  $ls
+  (al principio de la línea)
+   
+  muestra el contenido del directorio actual
+*/
+
+%{
+#include "macros.h"
+#include "ejemplo6.h"
+#include "ejemplo6.tab.h"
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+numero        [0-9]
+letra         [a-zA-Z]
+identificador {letra}({letra}|{numero})*
+
+%%
+[ \t] { ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+ { sscanf(yytext,"%lf",&yylval.val); 
+				    return NUMBER;}
+
+{identificador} { Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+
+^\$[^\n]*  { /* Ejecucion de un comando del shell */
+
+         BORRAR;
+         LUGAR(10,10);
+         if (strcmp(yytext,"$") != 0)
+            {
+             printf("\n Salida provisional al sistema operativo\n\n");
+             printf("\n comando ---> %s\n\n",yytext);
+             system(yytext+1);
+             putchar('\n');
+             }
+           else 
+            {
+             printf(" Si desea ejecutar un comando del sistema operativo ");
+             printf(" teclee: \n\t\t $comando ");
+            }
+
+         LUGAR(24,1);
+         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
+         /* Espera que se pulse ENTER */
+         while(getchar()!='\n')  ;
+
+         BORRAR;
+         LUGAR(2,1);
+         printf("Continue la ejecucion del programa --> %s \n\n",progname);
+         return FIN;
+         }
+
+:=      {return ASIGNACION;}
+#       { printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+;       {return FIN ;} 
+\n      {lineno++; return FIN;} 
+.       {return yytext[0];}
diff --git a/EjemplosBasicos/ejemplo6/macros.h b/EjemplosBasicos/ejemplo6/macros.h
new file mode 100644
index 0000000..4b77b98
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/macros.h
@@ -0,0 +1,7 @@
+#define LUGAR(x,y)   printf("\033[%d;%dH",x,y)
+#define BORRAR       printf("\33[2J") 
+#define PARPADEO     printf("%c[5m",27)
+#define APAGA        printf("%c[0m",27)
+#define INVERSO      printf("%c[7m",27)
+#define SUBRAYA      printf("%c[4m",27)
+#define INTENSIDAD   printf("%c[1m",27)
diff --git a/EjemplosBasicos/ejemplo6/math6.c b/EjemplosBasicos/ejemplo6/math6.c
new file mode 100644
index 0000000..df1a6a0
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/math6.c
@@ -0,0 +1,160 @@
+#include <math.h>
+#include <stdlib.h>
+#include <errno.h>
+/*  Referencia a la variable global que indica los codigos 
+   de los errores generados por las funciones matematicas */
+extern int errno;
+
+/* Prototipo de la funcion que comprueba errores matematicos **/
+double errcheck(double d, char *s);
+
+
+/*****************************************************************/
+/** Nombre: Log                                                 **/
+/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo neperiano                   **/
+/*****************************************************************/
+double Log(double x)
+{
+ return errcheck(log(x),"logaritmo neperiano");
+ }
+
+/*****************************************************************/
+/** Nombre: Log10                                               **/
+/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo decimal                     **/
+/*****************************************************************/
+double Log10(double x)
+{
+ return errcheck(log10(x),"logaritmo decimal");
+}
+
+/*****************************************************************/
+/** Nombre: Exp                                                 **/
+/** Labor que desarrolla: calcula la exponencial de un numero   **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion exponencial                           **/
+/*****************************************************************/
+double Exp(double x)
+{
+ return errcheck(exp(x),"exponencial");
+}
+
+/*****************************************************************/
+/** Nombre: Sqrt                                                **/
+/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion raiz cuadrada.                        **/
+/*****************************************************************/
+double Sqrt(double x)
+{
+ return errcheck(sqrt(x),"raiz cuadrada");
+}
+
+/*****************************************************************/
+/** Nombre: integer                                             **/
+/** Labor que desarrolla: calcula la parte entera de un numero  **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            calcular la parte entera.                        **/
+/*****************************************************************/
+
+double integer(double x)
+{
+ return  (double) (long) x;
+}
+
+/*****************************************************************/
+/** Nombre: Azar                                                **/
+/** Labor que desarrolla: calcula un numero aleatorio           **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametros:   ninguno                                       **/
+/*****************************************************************/
+double Azar()
+{
+ return (double) (long) rand() / RAND_MAX;
+}
+
+/*******************************************************************/
+/** Nombre: Atan2                                                 **/
+/** Labor que desarrolla: calcula el arco tangente doble, pero    **/
+/**       comprueba antes si hay algun error en los argumentos    **/ 
+/** Tipo de resultado: real de doble precision "double"           **/
+/** Parametro:                                                    **/
+/**  Nombre: x                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el numerador de la funcion Arco tangente   **/
+/**  Nombre: y                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el denominador de la funcion Arco tangente **/
+/*******************************************************************/
+
+double Atan2(double x, double y)
+{
+ return errcheck(atan(x/y),"arco tangente doble");
+}
+
+
+/*****************************************************************/
+/** Nombre: errcheck                                            **/
+/** Labor que desarrolla: comprueba si se ha producido un error **/
+/**       al realizar la evaluacion matematica del primer       **/
+/**       parametro. Si no hay error, entonces devuelve el      **/
+/**       primer parametro; en caso contrario muestra el error  **/ 
+/**       producido.                                            **/
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: d                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: almacenar el valor obtenido al aplicar una      **/
+/**            funcion matematica                               **/
+/**  Nombre: s                                                  **/
+/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
+/**     Mision: indica el nombre de la funcion que se ha        **/
+/**       utilizado para calcular el valor del primer parametro.**/
+/*****************************************************************/
+double errcheck(double d, char *s)
+{
+ if (errno==EDOM)
+    {
+     errno=0; /* Desactiva el error */
+     execerror(s," argumento fuera de dominio ");
+    }
+   else if (errno==ERANGE)
+           {
+            errno=0; /* Desactiva el error */
+            execerror(s," resultado fuera de rango ");
+           }
+ return d;
+}
diff --git a/EjemplosBasicos/ejemplo6/symbol6.c b/EjemplosBasicos/ejemplo6/symbol6.c
new file mode 100644
index 0000000..30bb3ce
--- /dev/null
+++ b/EjemplosBasicos/ejemplo6/symbol6.c
@@ -0,0 +1,86 @@
+#include <string.h>
+#include <stdlib.h>
+
+#include "ejemplo6.h"
+#include "ejemplo6.tab.h" /* Se genera al ejecutar yacc -d hoc3.y */
+
+/*  prototipo de la funcin que controla la reserva de memoria */
+char *emalloc(unsigned n);
+
+/* Tabla de simbolos: lista simplemente encadenada */
+static Symbol *symlist=0; 
+
+/**********************************************************************/
+/** Nombre: lookup                                                   **/
+/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
+/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
+/**        a la palabra; en caso contrario, devuelve NULL.           **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
+/** Parametros:                                                      **/ 
+/**  Nombre: s                                                       **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
+/**     Mision: suministra el nombre de la palabra buscada.          **/
+/**********************************************************************/
+
+Symbol *lookup (char *s) 
+{
+	Symbol *sp;
+
+	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
+		if (strcmp(sp->nombre,s)==0) return sp;
+	return 0;
+}
+
+/************************************************************************/
+/** Nombre: install                                                    **/
+/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
+/**        indicando el token que le corresponde y su valor inicial.   **/
+/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
+/** Parametros:                                                        **/ 
+/**  Nombre: s                                                         **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
+/**     Mision: suministra el nombre de la palabra a insertar.         **/
+/**  Nombre: t                                                         **/
+/**	Tipo:   entero "int"                                           **/
+/**     Mision: indica el token de la palabra.                         **/
+/**  Nombre: d                                                         **/
+/**	Tipo:   real de doble precision "double"                       **/
+/**     Mision: suministra un valor inicial.                           **/
+/************************************************************************/
+
+Symbol *install(char *s, int t, double d)
+{
+ Symbol *sp;
+ char *emalloc();
+
+ sp=(Symbol *) emalloc(sizeof(Symbol));
+ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
+ strcpy(sp->nombre,s);
+ sp->tipo=t;
+ sp->u.val=d;
+ sp->siguiente=symlist;
+ symlist=sp;
+ return sp;
+}
+
+/************************************************************************/
+/** Nombre: emalloc                                                    **/
+/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
+/**        se producen errores.                                        **/
+/**        Devuelve un puntero a la memoria reservada.                 **/
+/** Tipo de resultado: Puntero a caracter  "char *"                    **/
+/** Parametros:                                                        **/ 
+/**  Nombre: n                                                         **/
+/**	Tipo:   entero sin signo "unsigned"                            **/
+/**     Mision: indica la cantidad de bytes que se deben reservar      **/
+/************************************************************************/
+
+char *emalloc(unsigned n)
+{
+	char *p;
+	p=malloc(n);
+	if (p==0) execerror("\nFalta memoria\n",(char *)0);
+	return p;
+}
+
diff --git a/EjemplosBasicos/ejemplo7/Makefile b/EjemplosBasicos/ejemplo7/Makefile
new file mode 100644
index 0000000..160e99c
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/Makefile
@@ -0,0 +1,41 @@
+FUENTE = ejemplo7
+LEXICO = lexico7
+
+
+CC = gcc
+YFLAGS = -d -v
+LFLAGS = -lm -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o  init7.o   math7.o   symbol7.o  code7.o
+
+$(FUENTE)3.exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
+
+code7.o:  code7.c $(FUENTE).h
+	$(CC) -c code7.c
+
+init7.o:  init7.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c init7.c
+
+symbol7.o:  symbol7.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c symbol7.c
+
+math7.o:  math7.c $(FUENTE).h
+	$(CC) -c math7.c
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros objetos y auxiliares
+clean: 
+	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe $(FUENTE).output
+
+
diff --git a/EjemplosBasicos/ejemplo7/code7.c b/EjemplosBasicos/ejemplo7/code7.c
new file mode 100644
index 0000000..5ec8c15
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/code7.c
@@ -0,0 +1,258 @@
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo7.h"
+#include "ejemplo7.tab.h"
+
+
+#define NSTACK 256              /* Dimension maxima de la pila */
+static Datum stack[NSTACK];     /* La pila. En realidad es un array pero se usa como pila */
+static Datum *stackp;           /* siguiente lugar libre en la pila. Es un puntero */
+
+
+#define NPROG 2000 
+Inst prog[NPROG];  /* La maquina. Es un vector de instrucciones */
+Inst *progp;       /* Siguiente lugar libre para la generacion de codigo. Puntero a la siguiente instruccion libre */
+
+
+Inst *pc; /* Contador de programa durante la ejecucion */
+
+initcode() /* inicializacion para la generacion de codigo. Inicializa los punteros de la pila a la posicion inicial */
+{
+ stackp = stack;
+ progp = prog;
+}
+
+push(Datum d) /* meter d en la pila */
+{
+ 
+/* Comprobar que hay espacio en la pila para el nuevo valor o variable */
+ 
+ if (stackp >= &stack[NSTACK])
+     execerror (" Desborde superior de la pila ", (char *) 0);
+ 
+ *stackp++ =d; /* Apilar la variable o el numero y */
+               /* desplazar el puntero actual de la pila */
+}
+
+Datum pop() /* sacar y devolver de la pila el elemento de la cima */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+ return(*stackp);   /* Devolver variable o numero */
+}
+
+pop2() /* sacar y  NO devolver de la pila el elemento de la cima */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+}
+
+Inst *code(Inst f) /* Instalar una instruccion u operando */
+{
+ Inst *oprogp = progp;   /* Puntero auxiliar */
+ 
+/* Comprobar que hay espacio en el vector de instrucciones */ 
+
+ if (progp >= &prog[NPROG])
+     execerror (" Programa demasiado grande", (char *) 0);
+ 
+ *progp=f;        /* Asignar la instruccion o el puntero a la estructura */
+ progp++;         /* Desplazar una posicion hacia adelante */
+ return (oprogp);
+}
+
+execute(Inst *p)  /* ejecucion con la maquina */
+{
+ 
+/* El contador de programa pc se inicializa a la primera instruccion a */ 
+/* ejecutar */
+ 
+ for (pc=p; *pc != STOP;   )
+    (*(*pc++))();              /* Ejecucion de la instruccion y desplazar */
+}                              /* el contador de programa pc */
+
+
+/****************************************************************************/
+/****************************************************************************/
+
+assign() /* asignar el valor superior al siguiente valor */
+{
+ Datum d1,d2;
+ d1=pop();    /* Obtener variable */
+ d2=pop();    /* Obtener numero   */
+ 
+ if (d1.sym->tipo != VAR && d1.sym->tipo != INDEFINIDA) /* pregunta si es var o INDEFINIDA*/
+   execerror(" asignacion a un elemento que no es una variable ", 
+	     d1.sym->nombre); //si no es una variable peta
+  d1.sym->u.val=d2.val;   /* Asignar valor   */
+  d1.sym->tipo=VAR; //Se asigna el tipo a VAR
+  push(d2);               /* Apilar variable */ //esto es por si hace falta en una declaracion multiple
+} 
+
+constpush()  /* meter una constante en la pila */
+{
+ Datum d;
+ 
+ d.val= ((Symbol *)*pc++)->u.val;
+ push(d);
+}
+
+dividir() /* dividir los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el primer numero  */
+ d1=pop();      /* Obtener el segundo numero */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = d1.val / d2.val;    /* Dividir             */
+ push(d1);                    /* Apilar el resultado */
+}
+
+escribir() /* sacar de la pila el valor superior y escribirlo */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener numero */
+ 
+ printf("\t ---> %.8g\n",d.val);
+}
+
+eval() /* evaluar una variable en la pila */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener variable de la pila */
+ 
+/* Si la variable no esta definida */ 
+ if (d.sym->tipo == INDEFINIDA) 
+     execerror (" Variable no definida ", d.sym->nombre);
+ 
+ d.val=d.sym->u.val;  /* Sustituir variable por valor */
+ push(d);             /* Apilar valor */
+}
+
+funcion() /* evaluar una funcion predefinida en la cima de la pila */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener parametro para la funcion */
+
+ d.val= (*(double (*)())(*pc++))(d.val);
+ push(d);
+}
+
+/* resto de la division entera del segundo valor de la pila */
+/* por el valor de la cima */
+modulo() 
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el divisor */
+ d1=pop();      /* Obtener el dividendo */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = (int) d1.val % (int)  d2.val;  /* Resto */
+ push(d1);                               /* Apilar el resultado */
+}
+
+multiplicar() /* multiplicar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val * d2.val;   /* Multiplicar               */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+negativo() /* negacion del valor superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ d1.val = - d1.val;     /* Aplicar menos    */
+ push(d1);              /* Apilar resultado */
+}
+
+/* Esta funcion se puede omitir   */
+positivo() /* tomar el valor positivo del elemento superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ /* d1.val = + d1.val;*/     /* Aplicar mas    */
+ push(d1);              /* Apilar resultado */
+}
+
+potencia()  /* exponenciacion de los valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                      /* Obtener exponente   */
+ d1=pop();                      /* Obtener base        */
+ 
+ if ( (d1.val>=0) || ((int)d2.val == d2.val) )
+  {
+   d1.val = pow(d1.val,d2.val);   /* Elevar a potencia   */
+   push(d1);                      /* Apilar el resultado */
+  }
+ else 
+  {
+   char digitos[20];
+   sprintf(digitos,"%lf",d1.val);
+   execerror(" radicando negativo ", digitos);
+  }
+
+}
+
+
+restar()   /* restar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val - d2.val;   /* Restar                    */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+sumar()   /* sumar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val + d2.val;   /* Sumar                     */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+varpush()  /* meter una variable en la pila */
+{
+ Datum d;
+
+ d.sym=(Symbol *)(*pc++);
+ push(d);
+}
+
diff --git a/EjemplosBasicos/ejemplo7/ejemplo7.h b/EjemplosBasicos/ejemplo7/ejemplo7.h
new file mode 100644
index 0000000..418d37b
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/ejemplo7.h
@@ -0,0 +1,28 @@
+typedef struct Symbol 
+            { /* elementos de la tabla de simbolos */
+	        char *nombre;
+	        short tipo; /* NUMBER,VAR,FUNCION,INDEFINIDA,CONSTANTE */ 
+	        union {
+		       double val;      /* VAR, NUMBER, INDEFINIDA, CONSTANTE */
+		       double (*ptr)(); /* FUNCION  */
+		      } u;
+            struct Symbol *siguiente;
+	     } Symbol;
+
+Symbol *install(char *s, int t, double d), *lookup(char *);
+
+typedef union Datum { /* tipo de la pila del interprete */ 
+                     double val;
+                     Symbol *sym;
+                    } Datum;
+
+extern Datum pop();
+extern pop2();
+
+typedef int (*Inst)(); /* instruccion maquina */
+#define STOP (Inst) 0
+
+extern Inst prog[];
+extern  assign(), constpush(), dividir(), escribir(), eval(), funcion(),
+        modulo(), multiplicar(), negativo(), positivo(), potencia(), restar(),
+        sumar(), varpush();
diff --git a/EjemplosBasicos/ejemplo7/ejemplo7.y b/EjemplosBasicos/ejemplo7/ejemplo7.y
new file mode 100644
index 0000000..277199a
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/ejemplo7.y
@@ -0,0 +1,120 @@
+/*
+ Ejemplo 7
+ 
+ Realiza lo mismo que el ejemplo 5 pero genera un código intermedio 
+ que posteriormente es ejecutado
+
+*/
+
+%{
+
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo7.h"
+
+
+/* declaracion de "macros" para simplificar la escritura */
+#define code2(c1,c2)         code(c1); code(c2) 
+#define code3(c1,c2,c3)      code(c1); code(c2); code(c3)
+%}
+%union{               /* tipos de datos de la pila */
+       Symbol *sym;   /* puntero a la tabla de simbolos */
+       Inst   *inst;  /* instruccion de maquina */ 
+}
+
+%token FIN
+%token <sym> NUMBER VAR FUNCION_PREDEFINIDA INDEFINIDA CONSTANTE //el valor que tiene ahora es un puntero al lugar en la tabla de simbolos donde este almacenado el numero
+%right ASIGNACION
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'    
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list asgn FIN  {code2(pop2,STOP); return 1;}
+        | list expr FIN  {code2(escribir,STOP); return 1;}
+        | list error FIN {yyerrok;}
+        ; 
+
+asgn :    VAR ASIGNACION expr {code3(varpush,(Inst)$1,assign);}
+        | CONSTANTE ASIGNACION expr 
+          {execerror(" NO se pueden asignar datos a constantes ",$1->nombre);}
+	;
+
+expr :    NUMBER     {code2(constpush,(Inst)$1);} //primero se ejecuta esta (ejemplo de dato := 2). code2 es una macro que en el vector pone las dos funciones
+                                                    /* $1 es el atributo de numero, que es un puntero a la tabla de simbolos*/
+        | VAR        {code3(varpush,(Inst)$1,eval);} //eval es una funcion que evaluar la variable y dejar su valor en la pila
+        | CONSTANTE  {code3(varpush,(Inst)$1,eval);} 
+        | asgn       
+        | FUNCION_PREDEFINIDA '(' expr ')' {code2(funcion,(Inst)$1->u.ptr);}
+        | '(' expr ')'  
+        | expr '+' expr {code(sumar);} /* tio que lo suma porque ya los ha metido antes en la pila retrasado */
+        | expr '-' expr {code(restar);}
+        | expr '*' expr {code(multiplicar);}
+        | expr '/' expr {code(dividir);}
+        | expr '%' expr {code(modulo);}
+        | expr '^' expr {code(potencia);}
+        | '-' expr %prec UNARIO {code(negativo);}
+        | '+' expr %prec UNARIO {code(positivo);}
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+ /* Inicializacion de la tabla de simbolos */
+ init();
+
+/* Establece un estado viable para continuar despues de un error*/
+ setjmp(begin);
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch);
+
+/* initcode inicializa el vector de instrucciones y la pila del interprete */
+ for(initcode(); yyparse(); initcode()) execute(prog); 
+ /* la primera parte es incializar el vector de instrucciones y la pila de los valores del analisis
+ la segunda hace el analisis sintactico
+ y la tercera controla el fin de bucle, lo que va haciendo es dejando el vector listo para poder escribir en el */
+ return 0;
+}
+  
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(s,t) /* recuperacion de errores durante la ejecucion */
+char *s,*t;
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /* atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo7/init7.c b/EjemplosBasicos/ejemplo7/init7.c
new file mode 100644
index 0000000..b56c877
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/init7.c
@@ -0,0 +1,63 @@
+#include <math.h>
+
+#include "ejemplo7.h"
+#include "ejemplo7.tab.h"
+
+/* Prototipo de una nueva funcion matematica */
+extern double integer(double x);
+/* Prototipos de funciones matematicas que "controlan" posibles errores" */
+extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x);
+
+/* Constantes predefinidas */
+static struct{
+              char *nombre;
+	      double cval;
+	      } constantes[] = {
+	                    "PI",    3.14159265358979323846,
+	                    "E",     2.71828182845904523536,
+	                    "GAMMA", 0.57721566490153286060,
+	                    "DEG",  57.29577951308232087680,
+	                    "PHI",   1.61803398874989484820,
+	                    0,       0
+	                   };
+
+/* Funciones predefinidas */ 
+static struct {    
+	       char *nombre;
+	       double (*func)();
+              } funciones [] = {
+	                       "sin",   sin,
+		               "cos",   cos,
+		               "atan",  atan,
+		               "log",   Log,
+		               "log10", Log10,
+		               "exp",   Exp,
+		               "sqrt",  Sqrt,
+		               "int",   integer,
+		               "abs",   fabs,
+		               0,       0
+		              };
+
+/************************************************************************/
+/** Nombre: init                                                       **/
+/** Labor que desarrolla: Inserta  en la tabla de simbolos las         **/ 
+/**        constantes y las funciones  que se encuentran en las        **/
+/**        variables globales "consts" y "funciones"                   **/ 
+/** Tipo de resultado: entero "int" (tipo por defecto)                 **/
+/** Parametros: Ninguno.                                               **/
+/************************************************************************/
+
+init()
+{
+ int i;
+ Symbol *s;
+
+ for (i=0; constantes[i].nombre; i++)
+       install(constantes[i].nombre,CONSTANTE,constantes[i].cval);
+
+ for (i=0; funciones[i].nombre; i++)
+     {
+      s=install(funciones[i].nombre,FUNCION_PREDEFINIDA,0.0);
+      s->u.ptr=funciones[i].func;
+     }
+}
diff --git a/EjemplosBasicos/ejemplo7/lexico7.l b/EjemplosBasicos/ejemplo7/lexico7.l
new file mode 100644
index 0000000..e03d71e
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/lexico7.l
@@ -0,0 +1,58 @@
+%{
+#include "macros.h"
+#include "ejemplo7.h"
+#include "ejemplo7.tab.h"
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+numero        [0-9]
+letra         [a-zA-Z]
+identificador {letra}({letra}|{numero})*
+
+%%
+[ \t] { ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+ {double d;  
+                                   sscanf(yytext,"%lf",&d); //lo lee y lo instala en la tabla de simbolos al principio, pero en la cadena de entrada no pone nada
+                                 /* Instala el numero en la tabla de simbolos */
+				   yylval.sym=install("",NUMBER,d); //aqui se ve que no pone nada de nombre y lo instala como NUMBER
+				   return NUMBER;}
+
+{identificador} { Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0); //si no esta metida en la tabla de simbolos la instala como indefinida
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;} //si el tipo es indefinida devuelve VAR
+
+^\$[^\n]*  { /* Ejecucion de un comando del shell */
+
+         BORRAR;
+         LUGAR(10,10);
+         if (strcmp(yytext,"$") != 0)
+            {
+             printf("\n Salida provisional al sistema operativo\n\n");
+             printf("\n comando ---> %s\n\n",yytext);
+             system(yytext+1);
+             putchar('\n');
+             }
+           else 
+            {
+             printf(" Si desea ejecutar un comando del sistema operativo ");
+             printf(" teclee: \n\t\t $comando ");
+            }
+
+         LUGAR(24,1);
+         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
+         /* Espera que se pulse ENTER */
+         while(getchar()!='\n')  ;
+
+         BORRAR;
+         LUGAR(2,1);
+         printf("Continue la ejecucion del programa --> %s \n\n",progname);
+         }
+:=      {return ASIGNACION;} //devuelve el token asignacion
+^#       { printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+;       {return FIN ;} 
+\n      {lineno++; return FIN;} 
+.       {return yytext[0];}
diff --git a/EjemplosBasicos/ejemplo7/macros.h b/EjemplosBasicos/ejemplo7/macros.h
new file mode 100644
index 0000000..4b77b98
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/macros.h
@@ -0,0 +1,7 @@
+#define LUGAR(x,y)   printf("\033[%d;%dH",x,y)
+#define BORRAR       printf("\33[2J") 
+#define PARPADEO     printf("%c[5m",27)
+#define APAGA        printf("%c[0m",27)
+#define INVERSO      printf("%c[7m",27)
+#define SUBRAYA      printf("%c[4m",27)
+#define INTENSIDAD   printf("%c[1m",27)
diff --git a/EjemplosBasicos/ejemplo7/math7.c b/EjemplosBasicos/ejemplo7/math7.c
new file mode 100644
index 0000000..e1f2cb5
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/math7.c
@@ -0,0 +1,129 @@
+#include <math.h>
+#include <errno.h>
+#include "ejemplo7.h"
+
+/*  Referencia a la variable global que indica los codigos 
+   de los errores generados por las funciones matematicas */
+extern int errno;
+
+/* Prototipo de la funcion que comprueba errores matematicos **/
+double errcheck(double d, char *s);
+
+/*****************************************************************/
+/** Nombre: Log                                                 **/
+/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo neperiano                   **/
+/*****************************************************************/
+double Log(double x)
+{
+ return errcheck(log(x),"logaritmo neperiano");
+ }
+
+/*****************************************************************/
+/** Nombre: Log10                                               **/
+/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo decimal                     **/
+/*****************************************************************/
+double Log10(double x)
+{
+ return errcheck(log10(x),"logaritmo decimal");
+}
+
+/*****************************************************************/
+/** Nombre: Exp                                                 **/
+/** Labor que desarrolla: calcula la exponencial de un numero   **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion exponencial                           **/
+/*****************************************************************/
+double Exp(double x)
+{
+ return errcheck(exp(x),"exponencial");
+}
+
+/*****************************************************************/
+/** Nombre: Sqrt                                                **/
+/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion raiz cuadrada.                        **/
+/*****************************************************************/
+double Sqrt(double x)
+{
+ return errcheck(sqrt(x),"raiz cuadrada");
+}
+
+/*****************************************************************/
+/** Nombre: integer                                             **/
+/** Labor que desarrolla: calcula la parte entera de un numero  **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            calcular la parte entera.                        **/
+/*****************************************************************/
+
+double integer(double x)
+{
+ return  (double) (long) x;
+}
+
+/*****************************************************************/
+/** Nombre: errcheck                                            **/
+/** Labor que desarrolla: comprueba si se ha producido un error **/
+/**       al realizar la evaluacion matematica del primer       **/
+/**       parametro. Si no hay error, entonces devuelve el      **/
+/**       primer parametro; en caso contrario muestra el error  **/ 
+/**       producido.                                            **/
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: d                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: almacenar el valor obtenido al aplicar una      **/
+/**            funcion matematica                               **/
+/**  Nombre: s                                                  **/
+/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
+/**     Mision: indica el nombre de la funcion que se ha        **/
+/**       utilizado para calcular el valor del primer parametro.**/
+/*****************************************************************/
+double errcheck(double d, char *s)
+{
+ if (errno==EDOM)
+    {
+     errno=0; /* Desactiva el error */
+     execerror(s," argumento fuera de dominio ");
+    }
+   else if (errno==ERANGE)
+           {
+            errno=0; /* Desactiva el error */
+            execerror(s," resultado fuera de rango ");
+           }
+ return d;
+}
diff --git a/EjemplosBasicos/ejemplo7/symbol7.c b/EjemplosBasicos/ejemplo7/symbol7.c
new file mode 100644
index 0000000..9b59530
--- /dev/null
+++ b/EjemplosBasicos/ejemplo7/symbol7.c
@@ -0,0 +1,80 @@
+#include <string.h>
+#include <stdlib.h>
+
+#include "ejemplo7.h"
+#include "ejemplo7.tab.h" /* Se genera al ejecutar yacc -d hoc4.y */
+
+/* Tabla de simbolos: lista simple encadenada */
+static Symbol *symlist=0; 
+
+/**********************************************************************/
+/** Nombre: lookup                                                   **/
+/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
+/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
+/**        a la palabra; en caso contrario, devuelve NULL.           **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
+/** Parametros:                                                      **/ 
+/**  Nombre: s                                                       **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
+/**     Mision: suministra el nombre de la palabra buscada.          **/
+/**********************************************************************/
+Symbol *lookup (char *s) 
+{
+	Symbol *sp;
+
+	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
+		if (strcmp(sp->nombre,s)==0) return sp;
+	return 0;
+}
+
+/************************************************************************/
+/** Nombre: install                                                    **/
+/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
+/**        indicando el token que le corresponde y su valor inicial.   **/
+/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
+/** Parametros:                                                        **/ 
+/**  Nombre: s                                                         **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
+/**     Mision: suministra el nombre de la palabra a insertar.         **/
+/**  Nombre: t                                                         **/
+/**	Tipo:   entero "int"                                           **/
+/**     Mision: indica el token de la palabra.                         **/
+/**  Nombre: d                                                         **/
+/**	Tipo:   real de doble precision "double"                       **/
+/**     Mision: suministra un valor inicial.                           **/
+/************************************************************************/
+Symbol *install(char *s, int t, double d)
+{
+ Symbol *sp;
+ char *emalloc();
+
+ sp=(Symbol *) emalloc(sizeof(Symbol));
+ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
+ strcpy(sp->nombre,s);
+ sp->tipo=t;
+ sp->u.val=d;
+ sp->siguiente=symlist;
+ symlist=sp;
+ return sp;
+}
+
+/************************************************************************/
+/** Nombre: emalloc                                                    **/
+/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
+/**        se producen errores.                                        **/
+/**        Devuelve un puntero a la memoria reservada.                 **/
+/** Tipo de resultado: Puntero a caracter  "char *"                    **/
+/** Parametros:                                                        **/ 
+/**  Nombre: n                                                         **/
+/**	Tipo:   entero sin signo "unsigned"                            **/
+/**     Mision: indica la cantidad de bytes que se deben reservar      **/
+/************************************************************************/
+
+char *emalloc(unsigned n)
+{
+	char *p;
+	p=malloc(n);
+	if (p==0) execerror("\nFalta memoria\n",(char *)0);
+	return p;
+}
diff --git a/EjemplosBasicos/ejemplo8/Makefile b/EjemplosBasicos/ejemplo8/Makefile
new file mode 100644
index 0000000..fe53b91
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/Makefile
@@ -0,0 +1,39 @@
+FUENTE = ejemplo8
+LEXICO = lexico8
+
+
+CC = gcc
+YFLAGS = -d -v 
+LFLAGS = -lm -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o  init8.o math8.o symbol8.o  code8.o
+
+$(FUENTE)3.exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
+
+code8.o:  code8.c $(FUENTE).h
+	$(CC) -c code8.c
+
+init8.o:  init8.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c init8.c
+
+symbol8.o:  symbol8.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c symbol8.c
+
+math8.o:  math8.c $(FUENTE).h
+	$(CC) -c math8.c
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros objetos y auxiliares
+clean: 
+	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe $(FUENTE).output
diff --git a/EjemplosBasicos/ejemplo8/code8.c b/EjemplosBasicos/ejemplo8/code8.c
new file mode 100644
index 0000000..7f8ecef
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/code8.c
@@ -0,0 +1,282 @@
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo8.h"
+#include "ejemplo8.tab.h"
+
+
+#define NSTACK 256              /* Dimension maxima de la pila */
+static Datum stack[NSTACK];     /* La pila */
+static Datum *stackp;           /* siguiente lugar libre en la pila */
+
+
+#define NPROG 2000 
+Inst prog[NPROG];  /* La maquina */
+Inst *progp;       /* Siguiente lugar libre para la generacion de codigo */
+
+
+Inst *pc; /* Contador de programa durante la ejecucion */
+
+
+initcode() /* inicializacion para la generacion de codigo */
+{
+ stackp = stack;
+ progp = prog;
+}
+
+push(Datum d) /* meter d en la pila */
+{
+ 
+/* Comprobar que hay espacio en la pila para el nuevo valor o variable */
+ 
+ if (stackp >= &stack[NSTACK])
+     execerror (" Desborde superior de la pila ", (char *) 0);
+ 
+ *stackp++ =d; /* Apilar la variable o el numero y */
+               /* desplazar el puntero actual de la pila */
+}
+
+
+Datum pop() /* sacar y devolver de la pila el elemento de la cima */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+ return(*stackp);   /* Devolver variable o numero */
+}
+
+pop2() /* sacar y NO devolver de la pila el elemento de la cima */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+}
+
+Inst *code(Inst f) /* Instalar una instruccion u operando */
+{
+ Inst *oprogp = progp;   /* Puntero auxiliar */
+ 
+/* Comprobar que hay espacio en el vector de instrucciones */ 
+
+ if (progp >= &prog[NPROG])
+     execerror (" Programa demasiado grande", (char *) 0);
+ 
+ *progp=f;        /* Asignar la instruccion o el puntero a la estructura */
+ progp++;         /* Desplazar una posicion hacia adelante */
+ return (oprogp);
+}
+
+
+execute(Inst *p)  /* Ejecucion con la maquina */
+{
+ 
+/* El contador de programa pc se inicializa con la primera instruccion a */ 
+/* ejecutar */
+ 
+ for (pc=p; *pc != STOP;   )
+    (*(*pc++))();              /* Ejecucion de la instruccion y desplazar */
+}                              /* el contador de programa pc */
+
+/****************************************************************************/
+/****************************************************************************/
+
+assign() /* asignar el valor superior al siguiente valor */
+{
+ Datum d1,d2;
+ d1=pop();    /* Obtener variable */
+ d2=pop();    /* Obtener numero   */
+ 
+ if (d1.sym->tipo != VAR && d1.sym->tipo != INDEFINIDA)
+   execerror(" asignacion a un elemento que no es una variable ", 
+	     d1.sym->nombre);
+  d1.sym->u.val=d2.val;   /* Asignar valor   */
+  d1.sym->tipo=VAR;
+  push(d2);               /* Apilar variable */
+}
+
+constpush()  /* meter una constante en la pila */
+{
+ Datum d;
+ 
+ d.val= ((Symbol *)*pc++)->u.val;
+ push(d);
+}
+
+dividir() /* dividir los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el primer numero  */
+ d1=pop();      /* Obtener el segundo numero */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = d1.val / d2.val;    /* Dividir             */
+ push(d1);                    /* Apilar el resultado */
+}
+
+escribir() /* sacar de la pila el valor superior y escribirlo */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener numero */
+ 
+ printf("\t ---> %.8g\n",d.val);
+}
+
+eval() /* evaluar una variable en la pila */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener variable de la pila */
+ 
+/* Si la variable no esta definida */ 
+ if (d.sym->tipo == INDEFINIDA) 
+     execerror (" Variable no definida ", d.sym->nombre);
+ 
+ d.val=d.sym->u.val;  /* Sustituir variable por valor */
+ push(d);             /* Apilar valor */
+}
+
+funcion0() /* evaluar una funcion predefinida sin parametros */
+{
+ Datum d;
+ 
+ d.val= (*(double (*)())(*pc++))();
+ push(d);
+}
+
+funcion1() /* evaluar una funcion predefinida con un parametro */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener parametro para la funcion */
+
+ d.val= (*(double (*)())(*pc++))(d.val);
+ push(d);
+}
+
+funcion2() /* evaluar una funcion predefinida con dos parametros */
+{
+ Datum d1,d2;
+ 
+ d2=pop();  /* Obtener parametro para la funcion */
+ d1=pop();  /* Obtener parametro para la funcion */
+
+ d1.val= (*(double (*)())(*pc++))(d1.val,d2.val);
+ push(d1);
+}
+
+/****************************************************************************/
+/****************************************************************************/
+
+/* resto de la division entera del segundo valor de la pila */
+/* por el valor de la cima */
+modulo() 
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el divisor */
+ d1=pop();      /* Obtener el dividendo */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = (int) d1.val % (int)  d2.val;  /* Resto */
+ push(d1);                               /* Apilar el resultado */
+}
+
+multiplicar() /* multiplicar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val * d2.val;   /* Multiplicar               */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+negativo() /* negacion del valor superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ d1.val = - d1.val;     /* Aplicar menos    */
+ push(d1);              /* Apilar resultado */
+}
+
+/* Esta funcion se puede omitir   */
+positivo() /* tomar el valor positivo del elemento superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ /* d1.val = + d1.val;*/     /* Aplicar mas    */
+ push(d1);              /* Apilar resultado */
+}
+
+potencia()  /* exponenciacion de los valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                      /* Obtener exponente   */
+ d1=pop();                      /* Obtener base        */
+ 
+ if ( (d1.val>=0) || ((int)d2.val == d2.val) )
+  {
+   d1.val = pow(d1.val,d2.val);   /* Elevar a potencia   */
+   push(d1);                      /* Apilar el resultado */
+  }
+ else 
+  {
+   char digitos[20];
+   sprintf(digitos,"%lf",d1.val);
+   execerror(" radicando negativo ", digitos);
+  }
+
+}
+
+
+restar()   /* restar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val - d2.val;   /* Restar                    */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+sumar()   /* sumar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val + d2.val;   /* Sumar                     */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+varpush()  /* meter una variable en la pila */
+{
+ Datum d;
+
+ d.sym=(Symbol *)(*pc++);
+ push(d);
+}
+
diff --git a/EjemplosBasicos/ejemplo8/ejemplo8.h b/EjemplosBasicos/ejemplo8/ejemplo8.h
new file mode 100644
index 0000000..bec2b34
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/ejemplo8.h
@@ -0,0 +1,28 @@
+typedef struct Symbol 
+            { /* elementos de la tabla de simbolos */
+	        char *nombre;
+	        short tipo; /* NUMBER,VAR,FUNCION,INDEFINIDA,CONSTANTE */ 
+	        union {
+		       double val;      /* VAR, NUMBER, INDEFINIDA, CONSTANTE */
+		       double (*ptr)(); /* FUNCION  */
+		      } u;
+                 struct Symbol *siguiente;
+	     } Symbol;
+
+Symbol *install(), *lookup();
+
+typedef union Datum { /* tipo de la pila del interprete */ 
+                     double val;
+                     Symbol *sym;
+                    } Datum;
+
+extern Datum pop();
+extern pop2();
+
+typedef int (*Inst)(); /* instruccion maquina */
+#define STOP (Inst) 0
+
+extern Inst prog[];
+extern  assign(), constpush(), dividir(), escribir(), eval(), funcion0(),
+        funcion1(),funcion2(), modulo(), multiplicar(), negativo(), positivo(),
+        potencia(), restar(), sumar(), varpush();
diff --git a/EjemplosBasicos/ejemplo8/ejemplo8.y b/EjemplosBasicos/ejemplo8/ejemplo8.y
new file mode 100644
index 0000000..b37bfbe
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/ejemplo8.y
@@ -0,0 +1,120 @@
+/*
+  Ejemplo 8
+  
+   Se ha ampliado el ejemplo 7 para permitir funciones predefinidas con cero, uno y dos argumentos
+
+
+*/
+
+%{
+
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo8.h"
+
+#include "macros.h"
+
+#define code2(c1,c2)         code(c1); code(c2)
+#define code3(c1,c2,c3)      code(c1); code(c2); code(c3)
+%}
+
+%union{               /* tipos de datos de la pila */
+       Symbol *sym;   /* puntero a la tabla de simbolos */
+       Inst   *inst;  /* instruccion de maquina */ 
+}
+
+%token FIN
+%token <sym> NUMBER VAR INDEFINIDA FUNCION0_PREDEFINIDA CONSTANTE FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA
+%right ASIGNACION
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO
+%right '^'    
+%%
+
+list :       /* nada: epsilon produccion */
+        | list FIN
+        | list asgn FIN  {code2(pop2,STOP); return 1;}
+        | list expr FIN  {code2(escribir,STOP); return 1;}
+        | list error FIN {yyerrok;}
+        ; 
+
+asgn :    VAR ASIGNACION expr {code3(varpush,(Inst)$1,assign);}
+        | CONSTANTE ASIGNACION expr 
+          {execerror(" NO se pueden asignar datos a constantes ",$1->nombre);}
+	;
+
+expr :    NUMBER     {code2(constpush,(Inst)$1);}
+        | VAR        {code3(varpush,(Inst)$1,eval);} 
+        | CONSTANTE  {code3(varpush,(Inst)$1,eval);} 
+        | asgn
+        | FUNCION0_PREDEFINIDA '(' ')'       {code2(funcion0,(Inst)$1->u.ptr);}
+        | FUNCION1_PREDEFINIDA '(' expr ')'  {code2(funcion1,(Inst)$1->u.ptr);}
+        | FUNCION2_PREDEFINIDA '(' expr ',' expr ')' 
+					     {code2(funcion2,(Inst)$1->u.ptr);}
+        | '(' expr ')'  
+        | expr '+' expr {code(sumar);}
+        | expr '-' expr {code(restar);}
+        | expr '*' expr {code(multiplicar);}
+        | expr '/' expr {code(dividir);}
+        | expr '%' expr {code(modulo);}
+        | expr '^' expr {code(potencia);}
+        | '-' expr %prec UNARIO {code(negativo);}
+        | '+' expr %prec UNARIO {code(positivo);}
+	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+
+main(int argc, char *argv[])
+{
+ void fpecatch();
+
+ progname=argv[0];
+
+ /* Inicializacion de la tabla de simbolos */
+ init();
+
+/* Establece un estado viable para continuar despues de un error*/
+ setjmp(begin);
+
+/* Establece cual va ser la funcion para tratar los errores de punto flotante */
+ signal(SIGFPE,fpecatch);
+
+/* initcode inicializa el vector de instrucciones y la pila del interprete */
+ for(initcode(); yyparse(); initcode()) execute(prog);
+ return 0;
+}
+  
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(s,t) /* recuperacion de errores durante la ejecucion */
+char *s,*t;
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
diff --git a/EjemplosBasicos/ejemplo8/init8.c b/EjemplosBasicos/ejemplo8/init8.c
new file mode 100644
index 0000000..7a2da43
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/init8.c
@@ -0,0 +1,84 @@
+#include <math.h>
+
+#include "ejemplo8.h"
+#include "ejemplo8.tab.h"
+
+
+/* Prototipo de una nueva funcion matematica */
+extern double integer(double x), Azar();
+/* Prototipos de funciones matematicas que "controlan" posibles errores" */
+extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x),
+              Atan2(double x, double y);
+
+static struct{
+              char *nombre;
+	      double cval;
+	      } constantes[] = {
+	                    "PI",    3.14159265358979323846,
+	                    "E",     2.71828182845904523536,
+	                    "GAMMA", 0.57721566490153286060,
+	                    "DEG",  57.29577951308232087680,
+	                    "PHI",   1.61803398874989484820,
+	                    0,       0
+	                   };
+
+static struct {    /* Nombres predefinidos de funciones */ 
+	       char *nombre;
+	       double (*func)();
+              } funciones0[] = {		  
+                               "azar",  Azar,
+		               0,       0
+		              },
+		 funciones1[] = {
+	                       "seno",   sin,
+		               "coseno", cos,
+		               "atan",   atan,
+		               "log",    Log,
+		               "log10",  Log10,
+		               "exp",    Exp,
+		               "raiz",   Sqrt,
+		               "entero", integer,
+		               "abs",    fabs,
+		               0,        0
+		              },
+		funciones2[] = {
+                               "atan2", Atan2,
+		               0,       0
+				};
+
+/************************************************************************/
+/** Nombre: init                                                       **/
+/** Labor que desarrolla: Inserta  en la tabla de simbolos las         **/ 
+/**        constantes y las funciones  que se encuentran en las        **/
+/**        variables globales "consts" y "funciones"                   **/ 
+/** Tipo de resultado: entero "int" (tipo por defecto)                 **/
+/** Parametros: Ninguno.                                               **/
+/************************************************************************/
+
+init()
+{
+ int i;
+ Symbol *s;
+
+ for (i=0; constantes[i].nombre; i++)
+       install(constantes[i].nombre,CONSTANTE,constantes[i].cval);
+
+ for (i=0; funciones0[i].nombre; i++)
+     {
+      s=install(funciones0[i].nombre,FUNCION0_PREDEFINIDA,0.0);
+      s->u.ptr=funciones0[i].func;
+     }
+
+ for (i=0; funciones1[i].nombre; i++)
+     {
+      s=install(funciones1[i].nombre,FUNCION1_PREDEFINIDA,0.0);
+      s->u.ptr=funciones1[i].func;
+     }
+
+ for (i=0; funciones2[i].nombre; i++)
+     {
+      s=install(funciones2[i].nombre,FUNCION2_PREDEFINIDA,0.0);
+      s->u.ptr=funciones2[i].func;
+     }
+ 
+}
diff --git a/EjemplosBasicos/ejemplo8/lexico8.l b/EjemplosBasicos/ejemplo8/lexico8.l
new file mode 100644
index 0000000..3c543de
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/lexico8.l
@@ -0,0 +1,58 @@
+%{
+#include "macros.h"
+#include "ejemplo8.h"
+#include "ejemplo8.tab.h"
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+numero        [0-9]
+letra         [a-zA-Z]
+identificador {letra}({letra}|{numero})*
+
+%%
+[ \t] { ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+ {double d;  
+                                   sscanf(yytext,"%lf",&d);
+                                 /* Instala el numero en la tabla de simbolos */
+				   yylval.sym=install("",NUMBER,d); 
+				   return NUMBER;}
+
+{identificador} { Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+
+^\$[^\n]*  { /* Ejecucion de un comando del shell */
+
+         BORRAR;
+         LUGAR(10,10);
+         if (strcmp(yytext,"$") != 0)
+            {
+             printf("\n Salida provisional al sistema operativo\n\n");
+             printf("\n comando ---> %s\n\n",yytext);
+             system(yytext+1);
+             putchar('\n');
+             }
+           else 
+            {
+             printf(" Si desea ejecutar un comando del sistema operativo ");
+             printf(" teclee: \n\t\t $comando ");
+            }
+
+         LUGAR(24,1);
+         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
+         /* Espera que se pulse ENTER */
+         while(getchar()!='\n')  ;
+
+         BORRAR;
+         LUGAR(2,1);
+         printf("Continue la ejecucion del programa --> %s \n\n",progname);
+         }
+:=      {return ASIGNACION;}
+^#       { printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+;       {return FIN ;} 
+\n      {lineno++; return FIN;} 
+.       {return yytext[0];}
diff --git a/EjemplosBasicos/ejemplo8/macros.h b/EjemplosBasicos/ejemplo8/macros.h
new file mode 100644
index 0000000..4b77b98
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/macros.h
@@ -0,0 +1,7 @@
+#define LUGAR(x,y)   printf("\033[%d;%dH",x,y)
+#define BORRAR       printf("\33[2J") 
+#define PARPADEO     printf("%c[5m",27)
+#define APAGA        printf("%c[0m",27)
+#define INVERSO      printf("%c[7m",27)
+#define SUBRAYA      printf("%c[4m",27)
+#define INTENSIDAD   printf("%c[1m",27)
diff --git a/EjemplosBasicos/ejemplo8/math8.c b/EjemplosBasicos/ejemplo8/math8.c
new file mode 100644
index 0000000..eedd816
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/math8.c
@@ -0,0 +1,163 @@
+#include <math.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*  Referencia a la variable global que indica los codigos 
+   de los errores generados por las funciones matematicas */
+extern int errno;
+
+/* Prototipo de la funcion que comprueba errores matematicos **/
+double errcheck(double d, char *s);
+
+
+/*****************************************************************/
+/** Nombre: Log                                                 **/
+/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo neperiano                   **/
+/*****************************************************************/
+double Log(double x)
+{
+ return errcheck(log(x),"logaritmo neperiano");
+ }
+
+/*****************************************************************/
+/** Nombre: Log10                                               **/
+/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo decimal                     **/
+/*****************************************************************/
+double Log10(double x)
+{
+ return errcheck(log10(x),"logaritmo decimal");
+}
+
+/*****************************************************************/
+/** Nombre: Exp                                                 **/
+/** Labor que desarrolla: calcula la exponencial de un numero   **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion exponencial                           **/
+/*****************************************************************/
+double Exp(double x)
+{
+ return errcheck(exp(x),"exponencial");
+}
+
+/*****************************************************************/
+/** Nombre: Sqrt                                                **/
+/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion raiz cuadrada.                        **/
+/*****************************************************************/
+double Sqrt(double x)
+{
+ return errcheck(sqrt(x),"raiz cuadrada");
+}
+
+/*****************************************************************/
+/** Nombre: integer                                             **/
+/** Labor que desarrolla: calcula la parte entera de un numero  **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            calcular la parte entera.                        **/
+/*****************************************************************/
+
+double integer(double x)
+{
+ return  (double) (long) x;
+}
+
+/*****************************************************************/
+/** Nombre: Azar                                                **/
+/** Labor que desarrolla: calcula un numero aleatorio           **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametros:   ninguno                                       **/
+/*****************************************************************/
+double Azar()
+{
+ return (double) (long) rand() / RAND_MAX;
+}
+
+/*******************************************************************/
+/** Nombre: Atan2                                                 **/
+/** Labor que desarrolla: calcula el arco tangente doble, pero    **/
+/**       comprueba antes si hay algun error en los argumentos    **/ 
+/** Tipo de resultado: real de doble precision "double"           **/
+/** Parametro:                                                    **/
+/**  Nombre: x                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el numerador de la funcion Arco tangente   **/
+/**  Nombre: y                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el denominador de la funcion Arco tangente **/
+/*******************************************************************/
+
+double Atan2(double x, double y)
+{
+ return errcheck(atan(x/y),"arco tangente doble");
+}
+
+
+/*****************************************************************/
+/** Nombre: errcheck                                            **/
+/** Labor que desarrolla: comprueba si se ha producido un error **/
+/**       al realizar la evaluacion matematica del primer       **/
+/**       parametro. Si no hay error, entonces devuelve el      **/
+/**       primer parametro; en caso contrario muestra el error  **/ 
+/**       producido.                                            **/
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: d                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: almacenar el valor obtenido al aplicar una      **/
+/**            funcion matematica                               **/
+/**  Nombre: s                                                  **/
+/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
+/**     Mision: indica el nombre de la funcion que se ha        **/
+/**       utilizado para calcular el valor del primer parametro.**/
+/*****************************************************************/
+
+double errcheck(double d, char *s)
+{
+ if (errno==EDOM)
+    {
+     errno=0;
+     execerror(s," argumento fuera de dominio ");
+    }
+   else if (errno==ERANGE)
+           {
+            errno=0;
+            execerror(s," resultado fuera de rango ");
+           }
+ return d;
+}
diff --git a/EjemplosBasicos/ejemplo8/symbol8.c b/EjemplosBasicos/ejemplo8/symbol8.c
new file mode 100644
index 0000000..351ce63
--- /dev/null
+++ b/EjemplosBasicos/ejemplo8/symbol8.c
@@ -0,0 +1,80 @@
+#include <string.h>
+#include <stdlib.h>
+
+#include "ejemplo8.h"
+#include "ejemplo8.tab.h" /* Se genera al ejecutar yacc -d ejemplo8.y */
+
+/* Tabla de simbolos: lista simple encadenada */
+static Symbol *symlist=0; 
+
+/**********************************************************************/
+/** Nombre: lookup                                                   **/
+/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
+/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
+/**        a la palabra; en caso contrario, devuelve NULL.           **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
+/** Parametros:                                                      **/ 
+/**  Nombre: s                                                       **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
+/**     Mision: suministra el nombre de la palabra buscada.          **/
+/**********************************************************************/
+Symbol *lookup (char *s) 
+{
+	Symbol *sp;
+
+	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
+		if (strcmp(sp->nombre,s)==0) return sp;
+	return 0;
+}
+
+/************************************************************************/
+/** Nombre: install                                                    **/
+/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
+/**        indicando el token que le corresponde y su valor inicial.   **/
+/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
+/** Parametros:                                                        **/ 
+/**  Nombre: s                                                         **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
+/**     Mision: suministra el nombre de la palabra a insertar.         **/
+/**  Nombre: t                                                         **/
+/**	Tipo:   entero "int"                                           **/
+/**     Mision: indica el token de la palabra.                         **/
+/**  Nombre: d                                                         **/
+/**	Tipo:   real de doble precision "double"                       **/
+/**     Mision: suministra un valor inicial.                           **/
+/************************************************************************/
+Symbol *install(char *s, int t, double d)
+{
+ Symbol *sp;
+ char *emalloc();
+
+ sp=(Symbol *) emalloc(sizeof(Symbol));
+ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
+ strcpy(sp->nombre,s);
+ sp->tipo=t;
+ sp->u.val=d;
+ sp->siguiente=symlist;
+ symlist=sp;
+ return sp;
+}
+
+/************************************************************************/
+/** Nombre: emalloc                                                    **/
+/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
+/**        se producen errores.                                        **/
+/**        Devuelve un puntero a la memoria reservada.                 **/
+/** Tipo de resultado: Puntero a caracter  "char *"                    **/
+/** Parametros:                                                        **/ 
+/**  Nombre: n                                                         **/
+/**	Tipo:   entero sin signo "unsigned"                            **/
+/**     Mision: indica la cantidad de bytes que se deben reservar      **/
+/************************************************************************/
+
+char *emalloc(unsigned n)
+{
+	char *p;
+	p=malloc(n);
+	if (p==0) execerror("\nFalta memoria\n",(char *)0);
+	return p;
+}
diff --git a/EjemplosBasicos/ejemplo9/Makefile b/EjemplosBasicos/ejemplo9/Makefile
new file mode 100644
index 0000000..d2dbb35
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/Makefile
@@ -0,0 +1,39 @@
+FUENTE = ejemplo9
+LEXICO = lexico9
+
+
+CC = gcc
+YFLAGS = -d -v 
+LFLAGS = -lm -lfl 
+OBJS= $(FUENTE).tab.o lex.yy.o  init9.o math9.o symbol9.o  code9.o
+
+$(FUENTE)3.exe: $(OBJS) 
+	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
+
+code9.o:  code9.c $(FUENTE).h
+	$(CC) -c code9.c
+
+init9.o:  init9.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c init9.c
+
+symbol9.o:  symbol9.c $(FUENTE).h $(FUENTE).tab.h
+	$(CC) -c symbol9.c
+
+math9.o:  math9.c $(FUENTE).h
+	$(CC) -c math9.c
+
+lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c lex.yy.c
+
+lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
+	flex $(LEXICO).l
+
+$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
+	$(CC) -c $(FUENTE).tab.c
+
+$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
+	bison $(YFLAGS) $(FUENTE).y
+
+#Opcion para borrar los ficheros objetos y auxiliares
+clean: 
+	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe $(FUENTE).output
diff --git a/EjemplosBasicos/ejemplo9/code9.c b/EjemplosBasicos/ejemplo9/code9.c
new file mode 100644
index 0000000..2c689a2
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/code9.c
@@ -0,0 +1,493 @@
+#include <stdio.h>
+#include  <math.h>
+
+#include "ejemplo9.h"
+#include "ejemplo9.tab.h"
+
+#include "macros.h"
+
+#define NSTACK 256              /* Dimension maxima de la pila */
+static Datum stack[NSTACK];     /* La pila */
+static Datum *stackp;           /* siguiente lugar libre en la pila */
+
+#define NPROG 2000 
+Inst prog[NPROG];  /* La maquina */
+Inst *progp;       /* Siguiente lugar libre para la generacion de codigo */
+
+Inst *pc; /* Contador de programa durante la ejecucion */
+
+initcode() /* inicializacion para la generacion de codigo */
+{
+ stackp = stack;
+ progp = prog;
+}
+
+push(Datum d) /* meter d en la pila */
+{
+ 
+/* Comprobar que hay espacio en la pila para el nuevo valor o variable */
+ 
+ if (stackp >= &stack[NSTACK])
+     execerror (" Desborde superior de la pila ", (char *) 0);
+ 
+ *stackp++ =d; /* Apilar la variable o el numero y */
+               /* desplazar el puntero actual de la pila */
+}
+
+
+Datum pop() /* sacar y devolver de la pila el elemento de la cima */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+ return(*stackp);   /* Devolver variable o numero */
+}
+
+pop2() /* sacar y  NO devolver el elemento de la cima de la pila */
+{
+ 
+/* Comprobar que no se intenta leer fuera de la pila */ 
+/* En teoria no ocurrira nunca */
+ 
+ if (stackp <= stack)
+     execerror (" Desborde inferior de la pila ", (char *) 0);
+ 
+ --stackp;          /* Volver hacia atras una posicion en la pila */
+}
+
+Inst *code(Inst f) /* Instalar una instruccion u operando */
+{
+ Inst *oprogp = progp;   /* Puntero auxiliar */
+ 
+/* Comprobar que hay espacio en el vector de instrucciones */ 
+
+ if (progp >= &prog[NPROG])
+     execerror (" Programa demasiado grande", (char *) 0);
+ 
+ *progp=f;        /* Asignar la instruccion o el puntero a la estructura */
+ progp++;         /* Desplazar una posicion hacia adelante */
+ return (oprogp);
+}
+
+
+execute(Inst *p)  /* Ejecucion con la maquina */
+{
+ 
+/* El contador de programa pc se inicializa con la primera instruccion a */ 
+/* ejecutar */
+ 
+ for (pc=p; *pc != STOP;   )
+    (*(*pc++))();              /* Ejecucion de la instruccion y desplazar */
+}                              /* el contador de programa pc */
+
+/****************************************************************************/
+/****************************************************************************/
+
+assign() /* asignar el valor superior al siguiente valor */
+{
+ Datum d1,d2;
+ d1=pop();    /* Obtener variable */
+ d2=pop();    /* Obtener numero   */
+ 
+ if (d1.sym->tipo != VAR && d1.sym->tipo != INDEFINIDA)
+   execerror(" asignacion a un elemento que no es una variable ", 
+	     d1.sym->nombre);
+  d1.sym->u.val=d2.val;   /* Asignar valor   */
+  d1.sym->tipo=VAR;
+  push(d2);               /* Apilar variable */
+}
+
+constpush()  /* meter una constante en la pila */
+{
+ Datum d;
+ 
+ d.val= ((Symbol *)*pc++)->u.val;
+ push(d);
+}
+
+dividir() /* dividir los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el primer numero  */
+ d1=pop();      /* Obtener el segundo numero */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = d1.val / d2.val;    /* Dividir             */
+ push(d1);                    /* Apilar el resultado */
+}
+
+escribir() /* sacar de la pila el valor superior y escribirlo */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener numero */
+ 
+ printf("\t ---> %.8g\n",d.val);
+}
+
+eval() /* evaluar una variable en la pila */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener variable de la pila */
+ 
+/* Si la variable no esta definida */ 
+ if (d.sym->tipo == INDEFINIDA) 
+     execerror (" Variable no definida ", d.sym->nombre);
+ 
+ d.val=d.sym->u.val;  /* Sustituir variable por valor */
+ push(d);             /* Apilar valor */
+}
+
+funcion0() /* evaluar una funcion predefinida sin parametros */
+{
+ Datum d;
+ 
+ d.val= (*(double (*)())(*pc++))();
+ push(d);
+}
+
+funcion1() /* evaluar una funcion predefinida con un parametro */
+{
+ Datum d;
+ 
+ d=pop();  /* Obtener parametro para la funcion */
+
+ d.val= (*(double (*)())(*pc++))(d.val);
+ push(d);
+}
+
+funcion2() /* evaluar una funcion predefinida con dos parametros */
+{
+ Datum d1,d2;
+ 
+ d2=pop();  /* Obtener parametro para la funcion */
+ d1=pop();  /* Obtener parametro para la funcion */
+
+ d1.val= (*(double (*)())(*pc++))(d1.val,d2.val);
+ push(d1);
+}
+
+/* resto de la division entera del segundo valor de la pila */
+/* por el valor de la cima */
+modulo() 
+{
+ Datum d1,d2;
+ 
+ d2=pop();      /* Obtener el divisor */
+ d1=pop();      /* Obtener el dividendo */
+ 
+/* Comprobar si hay division por 0 */ 
+ 
+ if (d2.val == 0.0)
+     execerror (" Division por cero ", (char *) 0);
+ 
+ d1.val = (int) d1.val % (int)  d2.val;  /* Resto */
+ push(d1);                               /* Apilar el resultado */
+}
+
+multiplicar() /* multiplicar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val * d2.val;   /* Multiplicar               */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+negativo() /* negacion del valor superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ d1.val = - d1.val;     /* Aplicar menos    */
+ push(d1);              /* Apilar resultado */
+}
+
+/* Esta funcion se puede omitir   */
+positivo() /* tomar el valor positivo del elemento superior de la pila */
+{
+ Datum d1;
+ 
+ d1=pop();              /* Obtener numero   */
+ /* d1.val = + d1.val;*/     /* Aplicar mas    */
+ push(d1);              /* Apilar resultado */
+}
+
+potencia()  /* exponenciacion de los valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                      /* Obtener exponente   */
+ d1=pop();                      /* Obtener base        */
+ 
+ if ( (d1.val>=0) || ((int)d2.val == d2.val) )
+  {
+   d1.val = pow(d1.val,d2.val);   /* Elevar a potencia   */
+   push(d1);                      /* Apilar el resultado */
+  }
+ else 
+  {
+   char digitos[20];
+   sprintf(digitos,"%lf",d1.val);
+   execerror(" radicando negativo ", digitos);
+  }
+
+}
+
+restar()   /* restar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val - d2.val;   /* Restar                    */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+sumar()   /* sumar los dos valores superiores de la pila */
+{
+ Datum d1,d2;
+ 
+ d2=pop();                   /* Obtener el primer numero  */
+ d1=pop();                   /* Obtener el segundo numero */
+ d1.val = d1.val + d2.val;   /* Sumar                     */
+ push(d1);                   /* Apilar el resultado       */
+}
+
+varpush()  /* meter una variable en la pila */
+{
+ Datum d;
+
+ d.sym=(Symbol *)(*pc++);
+ push(d);
+}
+/****************************************************************************/
+/****************************************************************************/
+
+leervariable() /* Leer una variable numerica por teclado */
+{
+ Symbol *variable;
+ char c;
+
+ variable = (Symbol *)(*pc); 
+
+ /* Se comprueba si el identificador es una variable */ 
+  if ((variable->tipo == INDEFINIDA) || (variable->tipo == VAR))
+    { 
+    printf("Valor--> ");
+    while((c=getchar())=='\n') ;
+    ungetc(c,stdin);
+    scanf("%lf",&variable->u.val);
+    variable->tipo=VAR;
+    pc++;
+
+   }
+ else
+     execerror("No es una variable",variable->nombre);
+}           
+
+
+mayor_que()
+{
+ Datum d1,d2;
+ 
+ d2=pop();   /* Obtener el primer numero  */
+ d1=pop();   /* Obtener el segundo numero */
+ 
+ if (d1.val > d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);  /* Apilar resultado */
+}
+
+
+menor_que()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val < d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);    /* Apilar el resultado */
+}
+
+
+igual()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val == d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);    /* Apilar resultado */
+}
+
+mayor_igual()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val >= d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);    /* Apilar resultado */
+}
+
+
+menor_igual()
+{
+ Datum d1,d2;
+ 
+ d2=pop();     /* Obtener el primer numero  */
+ d1=pop();     /* Obtener el segundo numero */
+ 
+ if (d1.val <= d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);     /* Apilar resultado */
+}
+
+distinto()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val != d2.val)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);    /* Apilar resultado */
+}
+
+
+y_logico()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val==1 && d2.val==1)
+   d1.val= 1;
+ else 
+   d1.val=0;
+ 
+ push(d1);    /* Apilar el resultado */
+}
+
+
+o_logico()
+{
+ Datum d1,d2;
+ 
+ d2=pop();    /* Obtener el primer numero  */
+ d1=pop();    /* Obtener el segundo numero */
+ 
+ if (d1.val==1 || d2.val==1)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);    /* Apilar resultado */
+}
+
+
+negacion()
+{
+ Datum d1;
+ 
+ d1=pop();   /* Obtener numero */
+ 
+ if (d1.val==0)
+   d1.val= 1;
+ else
+   d1.val=0;
+ 
+ push(d1);   /* Apilar resultado */
+}
+
+
+whilecode()
+{
+ Datum d;
+ Inst *savepc = pc;    /* Puntero auxiliar para guardar pc */
+
+ execute(savepc+2);    /* Ejecutar codigo de la condicion */
+ 
+ d=pop();    /* Obtener el resultado de la condicion de la pila */
+ 
+ while(d.val)   /* Mientras se cumpla la condicion de que no sea nulo */
+    {
+     execute(*((Inst **)(savepc)));   /* Ejecutar codigo del bucle, con el doble casting ejecuta el cuerpo del bucle */
+     execute(savepc+2);               /* Ejecutar condicion */
+     d=pop();              /* Obtener el resultado de la condicion */
+    }
+ 
+/* Asignar a pc la posicion del vector de instrucciones que contiene */  
+/* la siguiente instruccion a ejecutar */ 
+ 
+ pc= *((Inst **)(savepc+1));  
+}
+
+ifcode()
+{
+ Datum d;
+ Inst *savepc = pc;   /* Puntero auxiliar para guardar pc */
+
+ execute(savepc+3);   /* Ejecutar condicion */
+ d=pop();             /* Obtener resultado de la condicion */
+ 
+ 
+/* Si se cumple la condici\A2n ejecutar el cuerpo del if */
+ 
+ if(d.val)
+   execute(*((Inst **)(savepc)));
+ 
+/* Si no se cumple la condicion se comprueba si existe parte else   */
+/* Esto se logra ya que la segunda posicion reservada contendria el */
+/* puntero a la primera instruccion del cuerpo del else en caso de  */
+/* existir, si no existe sera\A0 STOP, porque a la hora de generar    */
+/* codigo se inicializa con STOP.                                   */
+
+ else if  (*((Inst **)(savepc+1)))  /* parte else */
+   execute(*((Inst **)(savepc+1)));
+ 
+
+/* Asignar a pc la posicion del vector de instrucciones que contiene */  
+/* la siguiente instruccion a ejecutar */ 
+ 
+ pc= *((Inst **)(savepc+2));
+}
diff --git a/EjemplosBasicos/ejemplo9/code9.o b/EjemplosBasicos/ejemplo9/code9.o
new file mode 100644
index 0000000..988d810
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/code9.o differ
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.exe b/EjemplosBasicos/ejemplo9/ejemplo9.exe
new file mode 100755
index 0000000..33b9943
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/ejemplo9.exe differ
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.h b/EjemplosBasicos/ejemplo9/ejemplo9.h
new file mode 100644
index 0000000..4b0e75a
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/ejemplo9.h
@@ -0,0 +1,31 @@
+typedef struct Symbol
+         { /* entrada en la tabla de simbolos */
+             char *nombre;
+	     short tipo;  /* NUMBER,VAR,FUNCION,INDEFINIDA,CONSTANTE*/  
+	     union {
+		    double val;        /* VAR, NUMBER, INDEFINIDA, CONSTANTE */
+		    double (*ptr)();   /* FUNCION */
+                   } u;
+             struct Symbol * siguiente;
+         } Symbol;
+
+Symbol *install(), *lookup();
+
+typedef union Datum { /* tipo de la pila del interprete */ 
+                     double val;
+                     Symbol *sym;
+                    } Datum;
+
+extern Datum pop();
+extern pop2();
+
+typedef int (*Inst)(); /* instruccion maquina */
+#define STOP (Inst) 0
+
+extern Inst prog[], *progp, *code();
+
+extern  assign(), constpush(), dividir(), escribir(), eval(), funcion0(),
+        funcion1(),funcion2(), modulo(), multiplicar(), negativo(), positivo(),
+        potencia(), restar(), sumar(), varpush(), ifcode(), whilecode(),
+        mayor_que(), menor_que(), mayor_igual(),menor_igual(), igual(), 
+       distinto(), y_logico(), o_logico(), negacion(), leervariable();
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.output b/EjemplosBasicos/ejemplo9/ejemplo9.output
new file mode 100644
index 0000000..41873a2
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/ejemplo9.output
@@ -0,0 +1,1752 @@
+Terminals unused in grammar
+
+   INDEFINIDA
+
+
+Estado 87 conflictos: 1 desplazamiento(s)/reducción(ones)
+
+
+Gramática
+
+    0 $accept: list $end
+
+    1 list: %empty
+    2     | list stmt ';'
+    3     | list error ';'
+
+    4 stmt: %empty
+    5     | asgn
+    6     | PRINT expr
+    7     | READ '(' VAR ')'
+    8     | while cond stmt end
+    9     | if cond stmt end
+   10     | if cond stmt end ELSE stmt end
+   11     | '{' stmtlist '}'
+
+   12 asgn: VAR ASIGNACION expr
+   13     | CONSTANTE ASIGNACION expr
+
+   14 cond: '(' expr ')'
+
+   15 while: WHILE
+
+   16 if: IF
+
+   17 end: %empty
+
+   18 stmtlist: %empty
+   19         | stmtlist stmt ';'
+
+   20 expr: NUMBER
+   21     | VAR
+   22     | CONSTANTE
+   23     | asgn
+   24     | FUNCION0_PREDEFINIDA '(' ')'
+   25     | FUNCION1_PREDEFINIDA '(' expr ')'
+   26     | FUNCION2_PREDEFINIDA '(' expr ',' expr ')'
+   27     | '(' expr ')'
+   28     | expr '+' expr
+   29     | expr '-' expr
+   30     | expr '*' expr
+   31     | expr '/' expr
+   32     | expr '%' expr
+   33     | expr '^' expr
+   34     | '-' expr
+   35     | '+' expr
+   36     | expr MAYOR_QUE expr
+   37     | expr MAYOR_IGUAL expr
+   38     | expr MENOR_QUE expr
+   39     | expr MENOR_IGUAL expr
+   40     | expr IGUAL expr
+   41     | expr DISTINTO expr
+   42     | expr Y_LOGICO expr
+   43     | expr O_LOGICO expr
+   44     | NEGACION expr
+
+
+Terminales con las reglas donde aparecen
+
+$end (0) 0
+'%' (37) 32
+'(' (40) 7 14 24 25 26 27
+')' (41) 7 14 24 25 26 27
+'*' (42) 30
+'+' (43) 28 35
+',' (44) 26
+'-' (45) 29 34
+'/' (47) 31
+';' (59) 2 3 19
+'^' (94) 33
+'{' (123) 11
+'}' (125) 11
+error (256) 3
+NUMBER (258) 20
+VAR (259) 7 12 21
+CONSTANTE (260) 13 22
+FUNCION0_PREDEFINIDA (261) 24
+FUNCION1_PREDEFINIDA (262) 25
+FUNCION2_PREDEFINIDA (263) 26
+INDEFINIDA (264)
+PRINT (265) 6
+WHILE (266) 15
+IF (267) 16
+ELSE (268) 10
+READ (269) 7
+ASIGNACION (270) 12 13
+O_LOGICO (271) 43
+Y_LOGICO (272) 42
+MAYOR_QUE (273) 36
+MENOR_QUE (274) 38
+MENOR_IGUAL (275) 39
+MAYOR_IGUAL (276) 37
+DISTINTO (277) 41
+IGUAL (278) 40
+UNARIO (279)
+NEGACION (280) 44
+
+
+No terminales con las reglas donde aparecen
+
+$accept (38)
+    en la izquierda: 0
+list (39)
+    en la izquierda: 1 2 3, en la derecha: 0 2 3
+stmt (40)
+    en la izquierda: 4 5 6 7 8 9 10 11, en la derecha: 2 8 9 10 19
+asgn (41)
+    en la izquierda: 12 13, en la derecha: 5 23
+cond (42)
+    en la izquierda: 14, en la derecha: 8 9 10
+while (43)
+    en la izquierda: 15, en la derecha: 8
+if (44)
+    en la izquierda: 16, en la derecha: 9 10
+end (45)
+    en la izquierda: 17, en la derecha: 8 9 10
+stmtlist (46)
+    en la izquierda: 18 19, en la derecha: 11 19
+expr (47)
+    en la izquierda: 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
+    36 37 38 39 40 41 42 43 44, en la derecha: 6 12 13 14 25 26 27
+    28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44
+
+
+State 0
+
+    0 $accept: . list $end
+
+    $default  reduce usando la regla 1 (list)
+
+    list  ir al estado 1
+
+
+State 1
+
+    0 $accept: list . $end
+    2 list: list . stmt ';'
+    3     | list . error ';'
+
+    $end       desplazar e ir al estado 2
+    error      desplazar e ir al estado 3
+    VAR        desplazar e ir al estado 4
+    CONSTANTE  desplazar e ir al estado 5
+    PRINT      desplazar e ir al estado 6
+    WHILE      desplazar e ir al estado 7
+    IF         desplazar e ir al estado 8
+    READ       desplazar e ir al estado 9
+    '{'        desplazar e ir al estado 10
+
+    ';'  reduce usando la regla 4 (stmt)
+
+    stmt   ir al estado 11
+    asgn   ir al estado 12
+    while  ir al estado 13
+    if     ir al estado 14
+
+
+State 2
+
+    0 $accept: list $end .
+
+    $default  aceptar
+
+
+State 3
+
+    3 list: list error . ';'
+
+    ';'  desplazar e ir al estado 15
+
+
+State 4
+
+   12 asgn: VAR . ASIGNACION expr
+
+    ASIGNACION  desplazar e ir al estado 16
+
+
+State 5
+
+   13 asgn: CONSTANTE . ASIGNACION expr
+
+    ASIGNACION  desplazar e ir al estado 17
+
+
+State 6
+
+    6 stmt: PRINT . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 29
+
+
+State 7
+
+   15 while: WHILE .
+
+    $default  reduce usando la regla 15 (while)
+
+
+State 8
+
+   16 if: IF .
+
+    $default  reduce usando la regla 16 (if)
+
+
+State 9
+
+    7 stmt: READ . '(' VAR ')'
+
+    '('  desplazar e ir al estado 30
+
+
+State 10
+
+   11 stmt: '{' . stmtlist '}'
+
+    $default  reduce usando la regla 18 (stmtlist)
+
+    stmtlist  ir al estado 31
+
+
+State 11
+
+    2 list: list stmt . ';'
+
+    ';'  desplazar e ir al estado 32
+
+
+State 12
+
+    5 stmt: asgn .
+
+    $default  reduce usando la regla 5 (stmt)
+
+
+State 13
+
+    8 stmt: while . cond stmt end
+
+    '('  desplazar e ir al estado 33
+
+    cond  ir al estado 34
+
+
+State 14
+
+    9 stmt: if . cond stmt end
+   10     | if . cond stmt end ELSE stmt end
+
+    '('  desplazar e ir al estado 33
+
+    cond  ir al estado 35
+
+
+State 15
+
+    3 list: list error ';' .
+
+    $default  reduce usando la regla 3 (list)
+
+
+State 16
+
+   12 asgn: VAR ASIGNACION . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 36
+
+
+State 17
+
+   13 asgn: CONSTANTE ASIGNACION . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 37
+
+
+State 18
+
+   20 expr: NUMBER .
+
+    $default  reduce usando la regla 20 (expr)
+
+
+State 19
+
+   12 asgn: VAR . ASIGNACION expr
+   21 expr: VAR .
+
+    ASIGNACION  desplazar e ir al estado 16
+
+    $default  reduce usando la regla 21 (expr)
+
+
+State 20
+
+   13 asgn: CONSTANTE . ASIGNACION expr
+   22 expr: CONSTANTE .
+
+    ASIGNACION  desplazar e ir al estado 17
+
+    $default  reduce usando la regla 22 (expr)
+
+
+State 21
+
+   24 expr: FUNCION0_PREDEFINIDA . '(' ')'
+
+    '('  desplazar e ir al estado 38
+
+
+State 22
+
+   25 expr: FUNCION1_PREDEFINIDA . '(' expr ')'
+
+    '('  desplazar e ir al estado 39
+
+
+State 23
+
+   26 expr: FUNCION2_PREDEFINIDA . '(' expr ',' expr ')'
+
+    '('  desplazar e ir al estado 40
+
+
+State 24
+
+   35 expr: '+' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 41
+
+
+State 25
+
+   34 expr: '-' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 42
+
+
+State 26
+
+   44 expr: NEGACION . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 43
+
+
+State 27
+
+   27 expr: '(' . expr ')'
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 44
+
+
+State 28
+
+   23 expr: asgn .
+
+    $default  reduce usando la regla 23 (expr)
+
+
+State 29
+
+    6 stmt: PRINT expr .
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+
+    $default  reduce usando la regla 6 (stmt)
+
+
+State 30
+
+    7 stmt: READ '(' . VAR ')'
+
+    VAR  desplazar e ir al estado 59
+
+
+State 31
+
+   11 stmt: '{' stmtlist . '}'
+   19 stmtlist: stmtlist . stmt ';'
+
+    VAR        desplazar e ir al estado 4
+    CONSTANTE  desplazar e ir al estado 5
+    PRINT      desplazar e ir al estado 6
+    WHILE      desplazar e ir al estado 7
+    IF         desplazar e ir al estado 8
+    READ       desplazar e ir al estado 9
+    '{'        desplazar e ir al estado 10
+    '}'        desplazar e ir al estado 60
+
+    $default  reduce usando la regla 4 (stmt)
+
+    stmt   ir al estado 61
+    asgn   ir al estado 12
+    while  ir al estado 13
+    if     ir al estado 14
+
+
+State 32
+
+    2 list: list stmt ';' .
+
+    $default  reduce usando la regla 2 (list)
+
+
+State 33
+
+   14 cond: '(' . expr ')'
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 62
+
+
+State 34
+
+    8 stmt: while cond . stmt end
+
+    VAR        desplazar e ir al estado 4
+    CONSTANTE  desplazar e ir al estado 5
+    PRINT      desplazar e ir al estado 6
+    WHILE      desplazar e ir al estado 7
+    IF         desplazar e ir al estado 8
+    READ       desplazar e ir al estado 9
+    '{'        desplazar e ir al estado 10
+
+    $default  reduce usando la regla 4 (stmt)
+
+    stmt   ir al estado 63
+    asgn   ir al estado 12
+    while  ir al estado 13
+    if     ir al estado 14
+
+
+State 35
+
+    9 stmt: if cond . stmt end
+   10     | if cond . stmt end ELSE stmt end
+
+    VAR        desplazar e ir al estado 4
+    CONSTANTE  desplazar e ir al estado 5
+    PRINT      desplazar e ir al estado 6
+    WHILE      desplazar e ir al estado 7
+    IF         desplazar e ir al estado 8
+    READ       desplazar e ir al estado 9
+    '{'        desplazar e ir al estado 10
+
+    $default  reduce usando la regla 4 (stmt)
+
+    stmt   ir al estado 64
+    asgn   ir al estado 12
+    while  ir al estado 13
+    if     ir al estado 14
+
+
+State 36
+
+   12 asgn: VAR ASIGNACION expr .
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+
+    $default  reduce usando la regla 12 (asgn)
+
+
+State 37
+
+   13 asgn: CONSTANTE ASIGNACION expr .
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+
+    $default  reduce usando la regla 13 (asgn)
+
+
+State 38
+
+   24 expr: FUNCION0_PREDEFINIDA '(' . ')'
+
+    ')'  desplazar e ir al estado 65
+
+
+State 39
+
+   25 expr: FUNCION1_PREDEFINIDA '(' . expr ')'
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 66
+
+
+State 40
+
+   26 expr: FUNCION2_PREDEFINIDA '(' . expr ',' expr ')'
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 67
+
+
+State 41
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   35     | '+' expr .
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 35 (expr)
+
+
+State 42
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   34     | '-' expr .
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 34 (expr)
+
+
+State 43
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+   44     | NEGACION expr .
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 44 (expr)
+
+
+State 44
+
+   27 expr: '(' expr . ')'
+   28     | expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+    ')'          desplazar e ir al estado 68
+
+
+State 45
+
+   43 expr: expr O_LOGICO . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 69
+
+
+State 46
+
+   42 expr: expr Y_LOGICO . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 70
+
+
+State 47
+
+   36 expr: expr MAYOR_QUE . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 71
+
+
+State 48
+
+   38 expr: expr MENOR_QUE . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 72
+
+
+State 49
+
+   39 expr: expr MENOR_IGUAL . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 73
+
+
+State 50
+
+   37 expr: expr MAYOR_IGUAL . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 74
+
+
+State 51
+
+   41 expr: expr DISTINTO . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 75
+
+
+State 52
+
+   40 expr: expr IGUAL . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 76
+
+
+State 53
+
+   28 expr: expr '+' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 77
+
+
+State 54
+
+   29 expr: expr '-' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 78
+
+
+State 55
+
+   30 expr: expr '*' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 79
+
+
+State 56
+
+   31 expr: expr '/' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 80
+
+
+State 57
+
+   32 expr: expr '%' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 81
+
+
+State 58
+
+   33 expr: expr '^' . expr
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 82
+
+
+State 59
+
+    7 stmt: READ '(' VAR . ')'
+
+    ')'  desplazar e ir al estado 83
+
+
+State 60
+
+   11 stmt: '{' stmtlist '}' .
+
+    $default  reduce usando la regla 11 (stmt)
+
+
+State 61
+
+   19 stmtlist: stmtlist stmt . ';'
+
+    ';'  desplazar e ir al estado 84
+
+
+State 62
+
+   14 cond: '(' expr . ')'
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+    ')'          desplazar e ir al estado 85
+
+
+State 63
+
+    8 stmt: while cond stmt . end
+
+    $default  reduce usando la regla 17 (end)
+
+    end  ir al estado 86
+
+
+State 64
+
+    9 stmt: if cond stmt . end
+   10     | if cond stmt . end ELSE stmt end
+
+    $default  reduce usando la regla 17 (end)
+
+    end  ir al estado 87
+
+
+State 65
+
+   24 expr: FUNCION0_PREDEFINIDA '(' ')' .
+
+    $default  reduce usando la regla 24 (expr)
+
+
+State 66
+
+   25 expr: FUNCION1_PREDEFINIDA '(' expr . ')'
+   28     | expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+    ')'          desplazar e ir al estado 88
+
+
+State 67
+
+   26 expr: FUNCION2_PREDEFINIDA '(' expr . ',' expr ')'
+   28     | expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+    ','          desplazar e ir al estado 89
+
+
+State 68
+
+   27 expr: '(' expr ')' .
+
+    $default  reduce usando la regla 27 (expr)
+
+
+State 69
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+   43     | expr O_LOGICO expr .
+
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+
+    $default  reduce usando la regla 43 (expr)
+
+
+State 70
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   42     | expr Y_LOGICO expr .
+   43     | expr . O_LOGICO expr
+
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+
+    $default  reduce usando la regla 42 (expr)
+
+
+State 71
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   36     | expr MAYOR_QUE expr .
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 36 (expr)
+
+
+State 72
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   38     | expr MENOR_QUE expr .
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 38 (expr)
+
+
+State 73
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   39     | expr MENOR_IGUAL expr .
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 39 (expr)
+
+
+State 74
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   37     | expr MAYOR_IGUAL expr .
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 37 (expr)
+
+
+State 75
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   41     | expr DISTINTO expr .
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 41 (expr)
+
+
+State 76
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   40     | expr IGUAL expr .
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '+'  desplazar e ir al estado 53
+    '-'  desplazar e ir al estado 54
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 40 (expr)
+
+
+State 77
+
+   28 expr: expr . '+' expr
+   28     | expr '+' expr .
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 28 (expr)
+
+
+State 78
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   29     | expr '-' expr .
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '*'  desplazar e ir al estado 55
+    '/'  desplazar e ir al estado 56
+    '%'  desplazar e ir al estado 57
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 29 (expr)
+
+
+State 79
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   30     | expr '*' expr .
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 30 (expr)
+
+
+State 80
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   31     | expr '/' expr .
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 31 (expr)
+
+
+State 81
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   32     | expr '%' expr .
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 32 (expr)
+
+
+State 82
+
+   28 expr: expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   33     | expr '^' expr .
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    '^'  desplazar e ir al estado 58
+
+    $default  reduce usando la regla 33 (expr)
+
+
+State 83
+
+    7 stmt: READ '(' VAR ')' .
+
+    $default  reduce usando la regla 7 (stmt)
+
+
+State 84
+
+   19 stmtlist: stmtlist stmt ';' .
+
+    $default  reduce usando la regla 19 (stmtlist)
+
+
+State 85
+
+   14 cond: '(' expr ')' .
+
+    $default  reduce usando la regla 14 (cond)
+
+
+State 86
+
+    8 stmt: while cond stmt end .
+
+    $default  reduce usando la regla 8 (stmt)
+
+
+State 87
+
+    9 stmt: if cond stmt end .
+   10     | if cond stmt end . ELSE stmt end
+
+    ELSE  desplazar e ir al estado 90
+
+    ELSE      [reduce usando la regla 9 (stmt)]
+    $default  reduce usando la regla 9 (stmt)
+
+
+State 88
+
+   25 expr: FUNCION1_PREDEFINIDA '(' expr ')' .
+
+    $default  reduce usando la regla 25 (expr)
+
+
+State 89
+
+   26 expr: FUNCION2_PREDEFINIDA '(' expr ',' . expr ')'
+
+    NUMBER                desplazar e ir al estado 18
+    VAR                   desplazar e ir al estado 19
+    CONSTANTE             desplazar e ir al estado 20
+    FUNCION0_PREDEFINIDA  desplazar e ir al estado 21
+    FUNCION1_PREDEFINIDA  desplazar e ir al estado 22
+    FUNCION2_PREDEFINIDA  desplazar e ir al estado 23
+    '+'                   desplazar e ir al estado 24
+    '-'                   desplazar e ir al estado 25
+    NEGACION              desplazar e ir al estado 26
+    '('                   desplazar e ir al estado 27
+
+    asgn  ir al estado 28
+    expr  ir al estado 91
+
+
+State 90
+
+   10 stmt: if cond stmt end ELSE . stmt end
+
+    VAR        desplazar e ir al estado 4
+    CONSTANTE  desplazar e ir al estado 5
+    PRINT      desplazar e ir al estado 6
+    WHILE      desplazar e ir al estado 7
+    IF         desplazar e ir al estado 8
+    READ       desplazar e ir al estado 9
+    '{'        desplazar e ir al estado 10
+
+    $default  reduce usando la regla 4 (stmt)
+
+    stmt   ir al estado 92
+    asgn   ir al estado 12
+    while  ir al estado 13
+    if     ir al estado 14
+
+
+State 91
+
+   26 expr: FUNCION2_PREDEFINIDA '(' expr ',' expr . ')'
+   28     | expr . '+' expr
+   29     | expr . '-' expr
+   30     | expr . '*' expr
+   31     | expr . '/' expr
+   32     | expr . '%' expr
+   33     | expr . '^' expr
+   36     | expr . MAYOR_QUE expr
+   37     | expr . MAYOR_IGUAL expr
+   38     | expr . MENOR_QUE expr
+   39     | expr . MENOR_IGUAL expr
+   40     | expr . IGUAL expr
+   41     | expr . DISTINTO expr
+   42     | expr . Y_LOGICO expr
+   43     | expr . O_LOGICO expr
+
+    O_LOGICO     desplazar e ir al estado 45
+    Y_LOGICO     desplazar e ir al estado 46
+    MAYOR_QUE    desplazar e ir al estado 47
+    MENOR_QUE    desplazar e ir al estado 48
+    MENOR_IGUAL  desplazar e ir al estado 49
+    MAYOR_IGUAL  desplazar e ir al estado 50
+    DISTINTO     desplazar e ir al estado 51
+    IGUAL        desplazar e ir al estado 52
+    '+'          desplazar e ir al estado 53
+    '-'          desplazar e ir al estado 54
+    '*'          desplazar e ir al estado 55
+    '/'          desplazar e ir al estado 56
+    '%'          desplazar e ir al estado 57
+    '^'          desplazar e ir al estado 58
+    ')'          desplazar e ir al estado 93
+
+
+State 92
+
+   10 stmt: if cond stmt end ELSE stmt . end
+
+    $default  reduce usando la regla 17 (end)
+
+    end  ir al estado 94
+
+
+State 93
+
+   26 expr: FUNCION2_PREDEFINIDA '(' expr ',' expr ')' .
+
+    $default  reduce usando la regla 26 (expr)
+
+
+State 94
+
+   10 stmt: if cond stmt end ELSE stmt end .
+
+    $default  reduce usando la regla 10 (stmt)
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.tab.c b/EjemplosBasicos/ejemplo9/ejemplo9.tab.c
new file mode 100644
index 0000000..eb8d8b1
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/ejemplo9.tab.c
@@ -0,0 +1,1880 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 14 "ejemplo9.y" /* yacc.c:339  */
+
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo9.h"
+
+#include "macros.h"
+
+#define code2(c1,c2)         code(c1); code(c2)
+#define code3(c1,c2,c3)      code(c1); code(c2); code(c3)
+
+#line 78 "ejemplo9.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "ejemplo9.tab.h".  */
+#ifndef YY_YY_EJEMPLO9_TAB_H_INCLUDED
+# define YY_YY_EJEMPLO9_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    NUMBER = 258,
+    VAR = 259,
+    CONSTANTE = 260,
+    FUNCION0_PREDEFINIDA = 261,
+    FUNCION1_PREDEFINIDA = 262,
+    FUNCION2_PREDEFINIDA = 263,
+    INDEFINIDA = 264,
+    PRINT = 265,
+    WHILE = 266,
+    IF = 267,
+    ELSE = 268,
+    READ = 269,
+    ASIGNACION = 270,
+    O_LOGICO = 271,
+    Y_LOGICO = 272,
+    MAYOR_QUE = 273,
+    MENOR_QUE = 274,
+    MENOR_IGUAL = 275,
+    MAYOR_IGUAL = 276,
+    DISTINTO = 277,
+    IGUAL = 278,
+    UNARIO = 279,
+    NEGACION = 280
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 26 "ejemplo9.y" /* yacc.c:355  */
+             
+       Symbol *sym;    /* puntero a la tabla de simbolos */
+       Inst *inst;     /* instruccion de maquina */
+
+#line 149 "ejemplo9.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_EJEMPLO9_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 164 "ejemplo9.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   272
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  38
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  10
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  45
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  95
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   280
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,    28,     2,     2,
+      33,    34,    26,    24,    37,    25,     2,    27,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    32,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    31,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    35,     2,    36,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    29,
+      30
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    43,    43,    44,    45,    48,    49,    50,    51,    52,
+      57,    62,    68,    72,    73,    77,    80,    83,    86,    89,
+      90,    93,    94,    95,    96,    97,    98,    99,   101,   102,
+     103,   104,   105,   106,   107,   108,   109,   110,   111,   112,
+     113,   114,   115,   116,   117,   118
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NUMBER", "VAR", "CONSTANTE",
+  "FUNCION0_PREDEFINIDA", "FUNCION1_PREDEFINIDA", "FUNCION2_PREDEFINIDA",
+  "INDEFINIDA", "PRINT", "WHILE", "IF", "ELSE", "READ", "ASIGNACION",
+  "O_LOGICO", "Y_LOGICO", "MAYOR_QUE", "MENOR_QUE", "MENOR_IGUAL",
+  "MAYOR_IGUAL", "DISTINTO", "IGUAL", "'+'", "'-'", "'*'", "'/'", "'%'",
+  "UNARIO", "NEGACION", "'^'", "';'", "'('", "')'", "'{'", "'}'", "','",
+  "$accept", "list", "stmt", "asgn", "cond", "while", "if", "end",
+  "stmtlist", "expr", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,    43,    45,    42,    47,    37,   279,
+     280,    94,    59,    40,    41,   123,   125,    44
+};
+# endif
+
+#define YYPACT_NINF -58
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-58)))
+
+#define YYTABLE_NINF -6
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int16 yypact[] =
+{
+     -58,    51,   -58,   -29,   -13,    -9,    96,   -58,   -58,   -20,
+     -58,   -18,   -58,    -7,    -7,   -58,    96,    96,   -58,   -13,
+      -9,    -5,     3,    20,    96,    96,    96,    96,   -58,   212,
+      25,    62,   -58,    96,    80,    80,   212,   212,    23,    96,
+      96,    27,    27,    27,   136,    96,    96,    96,    96,    96,
+      96,    96,    96,    96,    96,    96,    96,    96,    96,    30,
+     -58,    22,   155,   -58,   -58,   -58,   174,   114,   -58,   227,
+     241,    -4,    -4,    -4,    -4,    -4,    -4,   -16,   -16,    27,
+      27,    27,    27,   -58,   -58,   -58,   -58,    46,   -58,    96,
+      80,   193,   -58,   -58,   -58
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,     0,     0,     0,    16,    17,     0,
+      19,     0,     6,     0,     0,     4,     0,     0,    21,    22,
+      23,     0,     0,     0,     0,     0,     0,     0,    24,     7,
+       0,     5,     3,     0,     5,     5,    13,    14,     0,     0,
+       0,    36,    35,    45,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      12,     0,     0,    18,    18,    25,     0,     0,    28,    44,
+      43,    37,    39,    40,    38,    42,    41,    29,    30,    31,
+      32,    33,    34,     8,    20,    15,     9,    10,    26,     0,
+       5,     0,    18,    27,    11
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -58,   -58,   -30,    -1,    54,   -58,   -58,   -57,   -58,    -8
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     1,    11,    28,    34,    13,    14,    86,    31,    29
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
+{
+      12,    61,    16,    15,    63,    64,    17,    87,    36,    37,
+      55,    56,    57,    30,    32,    58,    41,    42,    43,    44,
+      53,    54,    55,    56,    57,    62,    33,    58,    38,    59,
+      12,    66,    67,    12,    12,    94,    39,    69,    70,    71,
+      72,    73,    74,    75,    76,    77,    78,    79,    80,    81,
+      82,     2,     3,    40,    84,     4,     5,    65,    58,    90,
+      92,     6,     7,     8,    83,     9,     4,     5,    35,     0,
+       0,     0,     6,     7,     8,     0,     9,     0,     0,     0,
+       0,    91,     0,    -5,     4,     5,    10,     0,     0,    12,
+       6,     7,     8,     0,     9,     0,     0,    10,    60,    18,
+      19,    20,    21,    22,    23,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    10,     0,     0,     0,     0,
+      24,    25,     0,     0,     0,     0,    26,     0,     0,    27,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,     0,     0,    58,     0,     0,     0,     0,
+       0,    89,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    54,    55,    56,    57,     0,     0,    58,     0,     0,
+      68,    45,    46,    47,    48,    49,    50,    51,    52,    53,
+      54,    55,    56,    57,     0,     0,    58,     0,     0,    85,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,     0,     0,    58,     0,     0,    88,    45,
+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
+      56,    57,     0,     0,    58,     0,     0,    93,    45,    46,
+      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
+      57,     0,     0,    58,    46,    47,    48,    49,    50,    51,
+      52,    53,    54,    55,    56,    57,     0,     0,    58,    47,
+      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
+       0,     0,    58
+};
+
+static const yytype_int8 yycheck[] =
+{
+       1,    31,    15,    32,    34,    35,    15,    64,    16,    17,
+      26,    27,    28,    33,    32,    31,    24,    25,    26,    27,
+      24,    25,    26,    27,    28,    33,    33,    31,    33,     4,
+      31,    39,    40,    34,    35,    92,    33,    45,    46,    47,
+      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
+      58,     0,     1,    33,    32,     4,     5,    34,    31,    13,
+      90,    10,    11,    12,    34,    14,     4,     5,    14,    -1,
+      -1,    -1,    10,    11,    12,    -1,    14,    -1,    -1,    -1,
+      -1,    89,    -1,    32,     4,     5,    35,    -1,    -1,    90,
+      10,    11,    12,    -1,    14,    -1,    -1,    35,    36,     3,
+       4,     5,     6,     7,     8,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    35,    -1,    -1,    -1,    -1,
+      24,    25,    -1,    -1,    -1,    -1,    30,    -1,    -1,    33,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    -1,    -1,    31,    -1,    -1,    -1,    -1,
+      -1,    37,    16,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,
+      34,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,    34,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    -1,    -1,    31,    -1,    -1,    34,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    -1,    -1,    31,    -1,    -1,    34,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    -1,    -1,    31,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,    -1,    -1,    31,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      -1,    -1,    31
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    39,     0,     1,     4,     5,    10,    11,    12,    14,
+      35,    40,    41,    43,    44,    32,    15,    15,     3,     4,
+       5,     6,     7,     8,    24,    25,    30,    33,    41,    47,
+      33,    46,    32,    33,    42,    42,    47,    47,    33,    33,
+      33,    47,    47,    47,    47,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    31,     4,
+      36,    40,    47,    40,    40,    34,    47,    47,    34,    47,
+      47,    47,    47,    47,    47,    47,    47,    47,    47,    47,
+      47,    47,    47,    34,    32,    34,    45,    45,    34,    37,
+      13,    47,    40,    34,    45
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    38,    39,    39,    39,    40,    40,    40,    40,    40,
+      40,    40,    40,    41,    41,    42,    43,    44,    45,    46,
+      46,    47,    47,    47,    47,    47,    47,    47,    47,    47,
+      47,    47,    47,    47,    47,    47,    47,    47,    47,    47,
+      47,    47,    47,    47,    47,    47
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     3,     3,     0,     1,     2,     4,     4,
+       4,     7,     3,     3,     3,     3,     1,     1,     0,     0,
+       3,     1,     1,     1,     1,     3,     4,     6,     3,     3,
+       3,     3,     3,     3,     3,     2,     2,     3,     3,     3,
+       3,     3,     3,     3,     3,     2
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 3:
+#line 44 "ejemplo9.y" /* yacc.c:1646  */
+    {code(STOP); return 1;}
+#line 1334 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 4:
+#line 45 "ejemplo9.y" /* yacc.c:1646  */
+    {yyerrok;}
+#line 1340 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 48 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=progp;}
+#line 1346 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 49 "ejemplo9.y" /* yacc.c:1646  */
+    {code(pop2);}
+#line 1352 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 50 "ejemplo9.y" /* yacc.c:1646  */
+    {code(escribir); (yyval.inst) = (yyvsp[0].inst);}
+#line 1358 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 51 "ejemplo9.y" /* yacc.c:1646  */
+    {code2(leervariable,(Inst)(yyvsp[-1].sym));}
+#line 1364 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 53 "ejemplo9.y" /* yacc.c:1646  */
+    {
+                   ((yyvsp[-3].inst))[1]=(Inst)(yyvsp[-1].inst); /* cuerpo del bucle */
+                   ((yyvsp[-3].inst))[2]=(Inst)(yyvsp[0].inst); /* siguiente instruccion al bucle */
+                  }
+#line 1373 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 58 "ejemplo9.y" /* yacc.c:1646  */
+    {
+                   ((yyvsp[-3].inst))[1]=(Inst)(yyvsp[-1].inst); /* cuerpo del if */
+                   ((yyvsp[-3].inst))[3]=(Inst)(yyvsp[0].inst); /* siguiente instruccion al if */
+                  }
+#line 1382 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 63 "ejemplo9.y" /* yacc.c:1646  */
+    {
+                   ((yyvsp[-6].inst))[1]=(Inst)(yyvsp[-4].inst); /* cuerpo del if */
+                   ((yyvsp[-6].inst))[2]=(Inst)(yyvsp[-1].inst); /* cuerpo del else */
+                   ((yyvsp[-6].inst))[3]=(Inst)(yyvsp[0].inst); /* siguiente instruccion al if-else */
+                  }
+#line 1392 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 68 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst) = (yyvsp[-1].inst);}
+#line 1398 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 72 "ejemplo9.y" /* yacc.c:1646  */
+    { (yyval.inst)=(yyvsp[0].inst); code3(varpush,(Inst)(yyvsp[-2].sym),assign);}
+#line 1404 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 74 "ejemplo9.y" /* yacc.c:1646  */
+    {execerror(" NO se pueden asignar datos a constantes ",(yyvsp[-2].sym)->nombre);}
+#line 1410 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 77 "ejemplo9.y" /* yacc.c:1646  */
+    {code(STOP); (yyval.inst) =(yyvsp[-1].inst);}
+#line 1416 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 80 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)= code3(whilecode,STOP,STOP);}
+#line 1422 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 83 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)= code(ifcode); code3(STOP,STOP,STOP);}
+#line 1428 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 86 "ejemplo9.y" /* yacc.c:1646  */
+    {code(STOP); (yyval.inst) = progp;}
+#line 1434 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 89 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=progp;}
+#line 1440 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 93 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=code2(constpush,(Inst)(yyvsp[0].sym));}
+#line 1446 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 94 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=code3(varpush,(Inst)(yyvsp[0].sym),eval);}
+#line 1452 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 23:
+#line 95 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=code3(varpush,(Inst)(yyvsp[0].sym),eval);}
+#line 1458 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 25:
+#line 97 "ejemplo9.y" /* yacc.c:1646  */
+    {code2(funcion0,(Inst)(yyvsp[-2].sym)->u.ptr);}
+#line 1464 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 98 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=(yyvsp[-1].inst);code2(funcion1,(Inst)(yyvsp[-3].sym)->u.ptr);}
+#line 1470 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 100 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=(yyvsp[-3].inst);code2(funcion2,(Inst)(yyvsp[-5].sym)->u.ptr);}
+#line 1476 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 28:
+#line 101 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst) = (yyvsp[-1].inst);}
+#line 1482 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 102 "ejemplo9.y" /* yacc.c:1646  */
+    {code(sumar);}
+#line 1488 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 30:
+#line 103 "ejemplo9.y" /* yacc.c:1646  */
+    {code(restar);}
+#line 1494 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 104 "ejemplo9.y" /* yacc.c:1646  */
+    {code(multiplicar);}
+#line 1500 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 32:
+#line 105 "ejemplo9.y" /* yacc.c:1646  */
+    {code(dividir);}
+#line 1506 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 106 "ejemplo9.y" /* yacc.c:1646  */
+    {code(modulo);}
+#line 1512 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 34:
+#line 107 "ejemplo9.y" /* yacc.c:1646  */
+    {code(potencia);}
+#line 1518 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 108 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=(yyvsp[0].inst); code(negativo);}
+#line 1524 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 109 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=(yyvsp[0].inst); code(positivo);}
+#line 1530 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 110 "ejemplo9.y" /* yacc.c:1646  */
+    {code(mayor_que);}
+#line 1536 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 38:
+#line 111 "ejemplo9.y" /* yacc.c:1646  */
+    {code(mayor_igual);}
+#line 1542 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 39:
+#line 112 "ejemplo9.y" /* yacc.c:1646  */
+    {code(menor_que);}
+#line 1548 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 113 "ejemplo9.y" /* yacc.c:1646  */
+    {code(menor_igual);}
+#line 1554 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 114 "ejemplo9.y" /* yacc.c:1646  */
+    {code(igual);}
+#line 1560 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 115 "ejemplo9.y" /* yacc.c:1646  */
+    {code(distinto);}
+#line 1566 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 43:
+#line 116 "ejemplo9.y" /* yacc.c:1646  */
+    {code(y_logico);}
+#line 1572 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 44:
+#line 117 "ejemplo9.y" /* yacc.c:1646  */
+    {code(o_logico);}
+#line 1578 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 45:
+#line 118 "ejemplo9.y" /* yacc.c:1646  */
+    {(yyval.inst)=(yyvsp[0].inst); code(negacion);}
+#line 1584 "ejemplo9.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1588 "ejemplo9.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 121 "ejemplo9.y" /* yacc.c:1906  */
+
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+/* Dispositivo de entrada estndar de yylex() */
+extern FILE * yyin;
+
+main(int argc, char *argv[])
+{
+
+ void fpecatch();
+
+ /* Si se invoca el intrprete con un fichero de entrada */
+ /* entonces se establece como dispositivo de entrada para yylex() */
+ if (argc == 2) yyin = fopen(argv[1],"r");
+
+
+ progname=argv[0];
+
+ /* inicializacion de la tabla de simbolos */
+ init();
+
+/* Establece un estado viable para continuar despues de un error */
+ setjmp(begin);
+
+ /* Establece cual va a ser la funcion para tratar errores de punto flotante */
+ signal(SIGFPE,fpecatch); /* Excepcion de punto flotante*/
+
+/* initcode inicializa el vector de intrucciones y la pila del interprete */
+ for (initcode(); yyparse(); initcode()) execute(prog);
+
+ return 0;
+
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(s,t) /* recuperacion de errores durante la ejecucion */
+char *s,*t;
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
+
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.tab.h b/EjemplosBasicos/ejemplo9/ejemplo9.tab.h
new file mode 100644
index 0000000..6850ee9
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/ejemplo9.tab.h
@@ -0,0 +1,95 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_EJEMPLO9_TAB_H_INCLUDED
+# define YY_YY_EJEMPLO9_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    NUMBER = 258,
+    VAR = 259,
+    CONSTANTE = 260,
+    FUNCION0_PREDEFINIDA = 261,
+    FUNCION1_PREDEFINIDA = 262,
+    FUNCION2_PREDEFINIDA = 263,
+    INDEFINIDA = 264,
+    PRINT = 265,
+    WHILE = 266,
+    IF = 267,
+    ELSE = 268,
+    READ = 269,
+    ASIGNACION = 270,
+    O_LOGICO = 271,
+    Y_LOGICO = 272,
+    MAYOR_QUE = 273,
+    MENOR_QUE = 274,
+    MENOR_IGUAL = 275,
+    MAYOR_IGUAL = 276,
+    DISTINTO = 277,
+    IGUAL = 278,
+    UNARIO = 279,
+    NEGACION = 280
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 26 "ejemplo9.y" /* yacc.c:1909  */
+             
+       Symbol *sym;    /* puntero a la tabla de simbolos */
+       Inst *inst;     /* instruccion de maquina */
+
+#line 85 "ejemplo9.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_EJEMPLO9_TAB_H_INCLUDED  */
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.tab.o b/EjemplosBasicos/ejemplo9/ejemplo9.tab.o
new file mode 100644
index 0000000..1b9d638
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/ejemplo9.tab.o differ
diff --git a/EjemplosBasicos/ejemplo9/ejemplo9.y b/EjemplosBasicos/ejemplo9/ejemplo9.y
new file mode 100644
index 0000000..edba18c
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/ejemplo9.y
@@ -0,0 +1,185 @@
+/*
+
+ Ejemplo 9
+ 
+  Se ha ampliado el ejemplo 8 para permitir 
+  - operadores relacionales y lgicos
+  - sentencia condicional: if
+  - sentencia iterativa: while
+  - ejecutar las sentencias contenidas en un fichero indicado en la lnea de comandos
+    Por ejemplo:
+       > ./ejemplo9.exe factorial.txt
+*/
+
+%{
+#include <stdio.h>
+#include <math.h>
+
+#include "ejemplo9.h"
+
+#include "macros.h"
+
+#define code2(c1,c2)         code(c1); code(c2)
+#define code3(c1,c2,c3)      code(c1); code(c2); code(c3)
+%}
+
+%union{             
+       Symbol *sym;    /* puntero a la tabla de simbolos */
+       Inst *inst;     /* instruccion de maquina */
+}
+
+%token <sym> NUMBER VAR CONSTANTE FUNCION0_PREDEFINIDA FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA INDEFINIDA PRINT WHILE IF ELSE READ
+%type <inst> stmt asgn expr stmtlist cond while if end 
+%right ASIGNACION
+%left O_LOGICO
+%left Y_LOGICO
+%left MAYOR_QUE MENOR_QUE MENOR_IGUAL MAYOR_IGUAL DISTINTO IGUAL
+%left '+' '-'
+%left '*' '/' '%'
+%left UNARIO NEGACION
+%right '^'   
+%%
+
+list :    /* nada: epsilon produccion */ 
+        | list stmt  ';' {code(STOP); return 1;}
+        | list error ';'   {yyerrok;} 
+        ;
+
+stmt :    /* nada> epsilon produccion */  {$$=progp;}
+        | asgn          {code(pop2);}
+	| PRINT expr    {code(escribir); $$ = $2;}
+        | READ '(' VAR ')'    {code2(leervariable,(Inst)$3);}
+        | while cond stmt end  
+                  {
+                   ($1)[1]=(Inst)$3; /* cuerpo del bucle */
+                   ($1)[2]=(Inst)$4; /* siguiente instruccion al bucle */
+                  }
+        | if cond stmt end /* proposicion if sin parte else */
+                  {
+                   ($1)[1]=(Inst)$3; /* cuerpo del if */
+                   ($1)[3]=(Inst)$4; /* siguiente instruccion al if */
+                  }
+        | if cond stmt end ELSE stmt end /* proposicion if con parte else */
+                  {
+                   ($1)[1]=(Inst)$3; /* cuerpo del if */
+                   ($1)[2]=(Inst)$6; /* cuerpo del else */
+                   ($1)[3]=(Inst)$7; /* siguiente instruccion al if-else */
+                  }
+        | '{' stmtlist '}'  {$$ = $2;}
+        ;
+
+
+asgn :    VAR ASIGNACION expr { $$=$3; code3(varpush,(Inst)$1,assign);}
+        | CONSTANTE ASIGNACION expr 
+          {execerror(" NO se pueden asignar datos a constantes ",$1->nombre);}
+	;
+
+cond :    '(' expr ')' {code(STOP); $$ =$2;}
+        ;
+
+while:    WHILE      {$$= code3(whilecode,STOP,STOP);} //uno es para el cuerpo y el otro para el siguiente
+        ;
+
+if:       IF         {$$= code(ifcode); code3(STOP,STOP,STOP);}
+        ;
+
+end :    /* nada: produccion epsilon */  {code(STOP); $$ = progp;}
+        ;
+
+stmtlist:  /* nada: prodcuccion epsilon */ {$$=progp;}
+        | stmtlist stmt ';'
+        ;
+
+expr :    NUMBER     		{$$=code2(constpush,(Inst)$1);}
+        | VAR        		{$$=code3(varpush,(Inst)$1,eval);} 
+        | CONSTANTE      	{$$=code3(varpush,(Inst)$1,eval);}
+        | asgn
+        | FUNCION0_PREDEFINIDA '(' ')'      {code2(funcion0,(Inst)$1->u.ptr);}
+        | FUNCION1_PREDEFINIDA '(' expr ')' {$$=$3;code2(funcion1,(Inst)$1->u.ptr);}
+        | FUNCION2_PREDEFINIDA '(' expr ',' expr ')'
+                                            {$$=$3;code2(funcion2,(Inst)$1->u.ptr);}
+        | '(' expr ')'  	{$$ = $2;}
+        | expr '+' expr 	{code(sumar);}
+        | expr '-' expr 	{code(restar);}
+        | expr '*' expr 	{code(multiplicar);}
+        | expr '/' expr 	{code(dividir);}
+        | expr '%' expr 	{code(modulo);}
+        | expr '^' expr 	{code(potencia);}
+        |'-' expr %prec UNARIO 	{$$=$2; code(negativo);}
+        |'+' expr %prec UNARIO 	{$$=$2; code(positivo);}
+        | expr MAYOR_QUE expr 	{code(mayor_que);}
+        | expr MAYOR_IGUAL expr {code(mayor_igual);}
+        | expr MENOR_QUE expr 	{code(menor_que);}
+        | expr MENOR_IGUAL expr {code(menor_igual);}
+        | expr IGUAL expr 	{code(igual);}
+        | expr DISTINTO expr 	{code(distinto);}
+        | expr Y_LOGICO expr 	{code(y_logico);}
+        | expr O_LOGICO expr 	{code(o_logico);}
+        | NEGACION expr 	{$$=$2; code(negacion);}
+      	;
+
+%%
+
+#include <stdio.h>
+#include <ctype.h>
+#include <signal.h>
+#include <setjmp.h>
+
+jmp_buf begin;
+char *progname;
+int lineno = 1;
+/* Dispositivo de entrada estndar de yylex() */
+extern FILE * yyin;
+
+main(int argc, char *argv[])
+{
+
+ void fpecatch();
+
+ /* Si se invoca el intrprete con un fichero de entrada */
+ /* entonces se establece como dispositivo de entrada para yylex() */
+ if (argc == 2) yyin = fopen(argv[1],"r");
+
+
+ progname=argv[0];
+
+ /* inicializacion de la tabla de simbolos */
+ init();
+
+/* Establece un estado viable para continuar despues de un error */
+ setjmp(begin);
+
+ /* Establece cual va a ser la funcion para tratar errores de punto flotante */
+ signal(SIGFPE,fpecatch); /* Excepcion de punto flotante*/
+
+/* initcode inicializa el vector de intrucciones y la pila del interprete */
+ for (initcode(); yyparse(); initcode()) execute(prog);
+
+ return 0;
+
+}
+
+yyerror(char *s)
+{
+ warning(s,(char *) 0);
+}
+
+warning(char *s, char *t)
+{
+ fprintf(stderr," ** %s : %s", progname,s);
+ if (t) fprintf(stderr," ---> %s ",t);
+ fprintf(stderr,"  (linea %d)\n",lineno);
+}
+
+execerror(s,t) /* recuperacion de errores durante la ejecucion */
+char *s,*t;
+{
+ warning(s,t);
+  longjmp(begin,0);
+}
+
+void fpecatch()     /*  atrapa errores de punto flotante */
+{
+ execerror("error de punto flotante ",(char *)0);
+}
+
diff --git a/EjemplosBasicos/ejemplo9/factorial.txt b/EjemplosBasicos/ejemplo9/factorial.txt
new file mode 100644
index 0000000..acea1a4
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/factorial.txt
@@ -0,0 +1,16 @@
+read(dato);
+
+if (dato < 0) f := 0
+else
+    {
+     i:=dato;
+     f := 1;
+
+     while(i>1)
+       {
+        f := f * i;
+        i := i-1;
+      };
+    };
+
+print f; 
diff --git a/EjemplosBasicos/ejemplo9/init9.c b/EjemplosBasicos/ejemplo9/init9.c
new file mode 100644
index 0000000..3520f3e
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/init9.c
@@ -0,0 +1,93 @@
+#include <math.h>
+
+#include "ejemplo9.h"
+#include "ejemplo9.tab.h"
+
+/* Prototipo de una nueva funcion matematica */
+extern double integer(double x), Azar();
+/* Prototipos de funciones matematicas que "controlan" posibles errores" */
+extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x),
+              Atan2(double x, double y);
+
+static struct{
+              char *nombre;
+	      double cval;
+	      } constantes[] = {
+	                    "PI",    3.14159265358979323846,
+	                    "E",     2.71828182845904523536,
+	                    "GAMMA", 0.57721566490153286060,
+	                    "DEG",  57.29577951308232087680,
+	                    "PHI",   1.61803398874989484820,
+	                    0,       0
+	                   };
+
+static struct{   /* palabras clave */
+              char *nombre;
+	      int  kval;
+	      } keywords[] = {
+                              "if",        IF,
+			      "else",      ELSE,
+			      "while",     WHILE,
+			      "print",     PRINT,
+                              "read",      READ,
+			      0,           0,
+                             };
+
+static struct {    /* Nombres predefinidos de funciones */ 
+	       char *nombre;
+	       double (*func)();
+              } funciones0[] = {
+                               "azar", Azar,
+                                0, 0
+                              },
+                funciones1 [] = {
+	                       "seno",   sin,
+		               "coseno",   cos,
+		               "atan",  atan,
+		               "log",   Log,
+		               "log10", Log10,
+		               "exp",   Exp,
+		               "raiz",  Sqrt,
+		               "entero",   integer,
+		               "abs",   fabs,
+		               0,       0
+		              },
+              funciones2[] = {"atan2", Atan2,
+                               0, 0
+                             };
+/************************************************************************/
+/** Nombre: init                                                       **/
+/** Labor que desarrolla: Inserta  en la tabla de simbolos las         **/ 
+/**        constantes y las funciones  que se encuentran en las        **/
+/**        variables globales "consts" y "funciones"                   **/ 
+/** Tipo de resultado: entero "int" (tipo por defecto)                 **/
+/** Parametros: Ninguno.                                               **/
+/************************************************************************/
+init()
+{
+ int i;
+ Symbol *s;
+
+ for (i=0; constantes[i].nombre; i++)
+       install(constantes[i].nombre,CONSTANTE,constantes[i].cval);
+
+ for (i=0; keywords[i].nombre; i++)
+       install(keywords[i].nombre,keywords[i].kval,0.0);
+
+ for (i=0; funciones0[i].nombre; i++)
+     {
+      s=install(funciones0[i].nombre,FUNCION0_PREDEFINIDA,0.0);
+      s->u.ptr=funciones0[i].func;
+     }
+ for (i=0; funciones1[i].nombre; i++)
+     {
+      s=install(funciones1[i].nombre,FUNCION1_PREDEFINIDA,0.0);
+      s->u.ptr=funciones1[i].func;
+     }
+ for (i=0; funciones2[i].nombre; i++)
+     {
+      s=install(funciones2[i].nombre,FUNCION2_PREDEFINIDA,0.0);
+      s->u.ptr=funciones2[i].func;
+     }
+}
+
diff --git a/EjemplosBasicos/ejemplo9/init9.o b/EjemplosBasicos/ejemplo9/init9.o
new file mode 100644
index 0000000..d8f7166
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/init9.o differ
diff --git a/EjemplosBasicos/ejemplo9/lex.yy.c b/EjemplosBasicos/ejemplo9/lex.yy.c
new file mode 100644
index 0000000..36f2d85
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/lex.yy.c
@@ -0,0 +1,1870 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 18
+#define YY_END_OF_BUFFER 19
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[32] =
+    {   0,
+        0,    0,   19,   17,    1,   15,   10,   17,   17,    2,
+       17,    9,   17,    8,    3,   17,   14,   16,    7,   12,
+        2,    2,    2,   13,    5,    6,    4,    3,   11,   16,
+        0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    1,    5,    6,    1,    7,    1,    1,
+        1,    1,    1,    1,    1,    8,    1,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,   10,    1,   11,
+       12,   13,    1,    1,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+        1,    1,    1,    1,    1,    1,   14,   14,   14,   14,
+
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,    1,   15,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[16] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[33] =
+    {   0,
+        0,   11,   37,   38,   38,   38,   24,   28,   25,   10,
+       21,   20,   19,   18,   11,   14,   38,    0,   38,   38,
+       18,   17,   13,   38,   38,   38,   38,   14,   38,    0,
+       38,   23
+    } ;
+
+static yyconst flex_int16_t yy_def[33] =
+    {   0,
+       31,    1,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   32,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   32,
+        0,   31
+    } ;
+
+static yyconst flex_int16_t yy_nxt[54] =
+    {   0,
+        4,    5,    6,    7,    4,    4,    8,    9,   10,   11,
+       12,   13,   14,   15,   16,   17,   18,   22,   23,   28,
+       22,   23,   28,   30,   28,   21,   21,   28,   29,   27,
+       26,   25,   24,   21,   20,   19,   31,    3,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31
+    } ;
+
+static yyconst flex_int16_t yy_chk[54] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    2,    2,   10,   10,   15,
+       23,   23,   28,   32,   15,   22,   21,   28,   16,   14,
+       13,   12,   11,    9,    8,    7,    3,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "lexico9.l"
+#line 2 "lexico9.l"
+#include "macros.h"
+#include "ejemplo9.h"
+#include "ejemplo9.tab.h"
+extern char *progname;
+extern int lineno;
+/* definiciones regulares */
+#line 474 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 13 "lexico9.l"
+
+#line 661 "lex.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 32 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 38 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 14 "lexico9.l"
+{ ; } /* saltar los espacios y los tabuladores */
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 16 "lexico9.l"
+{double d;  
+                                   sscanf(yytext,"%lf",&d);
+                                 /* Instala el numero en la tabla de simbolos */
+				   yylval.sym=install("",NUMBER,d); 
+				   return NUMBER;}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 22 "lexico9.l"
+{ Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 28 "lexico9.l"
+{return MAYOR_IGUAL;}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 29 "lexico9.l"
+{return MENOR_IGUAL;}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 30 "lexico9.l"
+{return IGUAL;}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 31 "lexico9.l"
+{return DISTINTO;}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 32 "lexico9.l"
+{return MAYOR_QUE;}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 33 "lexico9.l"
+{return MENOR_QUE;}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 34 "lexico9.l"
+{return NEGACION;}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 35 "lexico9.l"
+{return O_LOGICO;}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 36 "lexico9.l"
+{return Y_LOGICO;}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 37 "lexico9.l"
+{return ASIGNACION;}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 38 "lexico9.l"
+{printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+	YY_BREAK
+case 15:
+/* rule 15 can match eol */
+YY_RULE_SETUP
+#line 39 "lexico9.l"
+{lineno++; } /* no se devuelve nada, contina el analisis lxico */
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 40 "lexico9.l"
+{ /* Ejecucion de un comando del shell */
+
+         BORRAR;
+         LUGAR(10,10);
+         if (strcmp(yytext,"$") != 0)
+            {
+             printf("\n Salida provisional al sistema operativo\n\n");
+             printf("\n comando ---> %s\n\n",yytext);
+             system(yytext+1);
+             putchar('\n');
+             }
+           else 
+            {
+             printf(" Si desea ejecutar un comando del sistema operativo ");
+             printf(" teclee: \n\t\t $comando ");
+            }
+
+         LUGAR(24,1);
+         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
+         /* Espera que se pulse ENTER */
+         while(getchar()!='\n')  ;
+
+         BORRAR;
+         LUGAR(2,1);
+         printf("Continue la ejecucion del programa --> %s \n\n",progname);
+         /* no se devuelve nada, contina el analisis lxico */
+         }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 67 "lexico9.l"
+{return yytext[0];}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 68 "lexico9.l"
+ECHO;
+	YY_BREAK
+#line 870 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 32 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 32 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 31);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 68 "lexico9.l"
diff --git a/EjemplosBasicos/ejemplo9/lex.yy.o b/EjemplosBasicos/ejemplo9/lex.yy.o
new file mode 100644
index 0000000..1921f82
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/lex.yy.o differ
diff --git a/EjemplosBasicos/ejemplo9/lexico9.l b/EjemplosBasicos/ejemplo9/lexico9.l
new file mode 100644
index 0000000..44f3018
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/lexico9.l
@@ -0,0 +1,67 @@
+%{
+#include "macros.h"
+#include "ejemplo9.h"
+#include "ejemplo9.tab.h"
+extern char *progname;
+extern int lineno;
+%}
+/* definiciones regulares */
+numero        [0-9]
+letra         [a-zA-Z]
+identificador {letra}({letra}|{numero})*
+
+%%
+[ \t] { ; } /* saltar los espacios y los tabuladores */
+
+{numero}+\.?|{numero}*\.{numero}+ {double d;  
+                                   sscanf(yytext,"%lf",&d);
+                                 /* Instala el numero en la tabla de simbolos */
+				   yylval.sym=install("",NUMBER,d); 
+				   return NUMBER;}
+
+{identificador} { Symbol *s;
+                   if ((s=lookup(yytext)) == 0)
+                               s = install (yytext, INDEFINIDA, 0.0);
+                    yylval.sym = s;
+                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
+
+">="	{return MAYOR_IGUAL;}
+"<="	{return MENOR_IGUAL;}
+"=="	{return IGUAL;}
+"!="	{return DISTINTO;}
+">"	{return MAYOR_QUE;}
+"<"	{return MENOR_QUE;}
+"!"	{return NEGACION;}
+"||"	{return O_LOGICO;}
+"&&"	{return Y_LOGICO;}
+":="      {return ASIGNACION;}
+^#       {printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
+\n      {lineno++; } /* no se devuelve nada, contina el analisis lxico */
+^\$[^\n]*  { /* Ejecucion de un comando del shell */
+
+         BORRAR;
+         LUGAR(10,10);
+         if (strcmp(yytext,"$") != 0)
+            {
+             printf("\n Salida provisional al sistema operativo\n\n");
+             printf("\n comando ---> %s\n\n",yytext);
+             system(yytext+1);
+             putchar('\n');
+             }
+           else 
+            {
+             printf(" Si desea ejecutar un comando del sistema operativo ");
+             printf(" teclee: \n\t\t $comando ");
+            }
+
+         LUGAR(24,1);
+         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
+         /* Espera que se pulse ENTER */
+         while(getchar()!='\n')  ;
+
+         BORRAR;
+         LUGAR(2,1);
+         printf("Continue la ejecucion del programa --> %s \n\n",progname);
+         /* no se devuelve nada, contina el analisis lxico */
+         }
+.       {return yytext[0];}
diff --git a/EjemplosBasicos/ejemplo9/macros.h b/EjemplosBasicos/ejemplo9/macros.h
new file mode 100644
index 0000000..4b77b98
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/macros.h
@@ -0,0 +1,7 @@
+#define LUGAR(x,y)   printf("\033[%d;%dH",x,y)
+#define BORRAR       printf("\33[2J") 
+#define PARPADEO     printf("%c[5m",27)
+#define APAGA        printf("%c[0m",27)
+#define INVERSO      printf("%c[7m",27)
+#define SUBRAYA      printf("%c[4m",27)
+#define INTENSIDAD   printf("%c[1m",27)
diff --git a/EjemplosBasicos/ejemplo9/math9.c b/EjemplosBasicos/ejemplo9/math9.c
new file mode 100644
index 0000000..59ede65
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/math9.c
@@ -0,0 +1,161 @@
+#include <math.h>
+#include <stdlib.h>
+#include <errno.h>
+/*  Referencia a la variable global que indica los codigos 
+   de los errores generados por las funciones matematicas */
+extern int errno;
+
+/* Prototipo de la funcion que comprueba errores matematicos **/
+double errcheck(double d, char *s);
+
+
+/*****************************************************************/
+/** Nombre: Log                                                 **/
+/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo neperiano                   **/
+/*****************************************************************/
+double Log(double x)
+{
+ return errcheck(log(x),"logaritmo neperiano");
+ }
+
+/*****************************************************************/
+/** Nombre: Log10                                               **/
+/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
+/**       numero real, pero comprueba antes si hay algun error  **/
+/**       en el argumento.                                      **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion logaritmo decimal                     **/
+/*****************************************************************/
+double Log10(double x)
+{
+ return errcheck(log10(x),"logaritmo decimal");
+}
+
+/*****************************************************************/
+/** Nombre: Exp                                                 **/
+/** Labor que desarrolla: calcula la exponencial de un numero   **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion exponencial                           **/
+/*****************************************************************/
+double Exp(double x)
+{
+ return errcheck(exp(x),"exponencial");
+}
+
+/*****************************************************************/
+/** Nombre: Sqrt                                                **/
+/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            la funcion raiz cuadrada.                        **/
+/*****************************************************************/
+double Sqrt(double x)
+{
+ return errcheck(sqrt(x),"raiz cuadrada");
+}
+
+/*****************************************************************/
+/** Nombre: integer                                             **/
+/** Labor que desarrolla: calcula la parte entera de un numero  **/
+/**       real, pero comprueba antes si hay algun error en el   **/
+/**       argumento.                                            **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: x                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: indica el numero al cual se le va aplicar       **/
+/**            calcular la parte entera.                        **/
+/*****************************************************************/
+
+double integer(double x)
+{
+ return  (double) (long) x;
+}
+
+/*****************************************************************/
+/** Nombre: Azar                                                **/
+/** Labor que desarrolla: calcula un numero aleatorio           **/ 
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametros:   ninguno                                       **/
+/*****************************************************************/
+double Azar()
+{
+ return (double) (long) rand() / RAND_MAX;
+}
+
+/*******************************************************************/
+/** Nombre: Atan2                                                 **/
+/** Labor que desarrolla: calcula el arco tangente doble, pero    **/
+/**       comprueba antes si hay algun error en los argumentos    **/ 
+/** Tipo de resultado: real de doble precision "double"           **/
+/** Parametro:                                                    **/
+/**  Nombre: x                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el numerador de la funcion Arco tangente   **/
+/**  Nombre: y                                                    **/
+/**    	Tipo: real de doble precision "double"                    **/
+/**     Mision: indica el denominador de la funcion Arco tangente **/
+/*******************************************************************/
+
+double Atan2(double x, double y)
+{
+ return errcheck(atan(x/y),"arco tangente doble");
+}
+
+
+/*****************************************************************/
+/** Nombre: errcheck                                            **/
+/** Labor que desarrolla: comprueba si se ha producido un error **/
+/**       al realizar la evaluacion matematica del primer       **/
+/**       parametro. Si no hay error, entonces devuelve el      **/
+/**       primer parametro; en caso contrario muestra el error  **/ 
+/**       producido.                                            **/
+/** Tipo de resultado: real de doble precision "double"         **/
+/** Parametro:                                                  **/
+/**  Nombre: d                                                  **/
+/**    	Tipo: real de doble precision "double"                  **/
+/**     Mision: almacenar el valor obtenido al aplicar una      **/
+/**            funcion matematica                               **/
+/**  Nombre: s                                                  **/
+/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
+/**     Mision: indica el nombre de la funcion que se ha        **/
+/**       utilizado para calcular el valor del primer parametro.**/
+/*****************************************************************/
+
+double errcheck(double d, char *s)
+{
+ if (errno==EDOM)
+    {
+     errno=0;
+     execerror(s," argumento fuera de dominio ");
+    }
+   else if (errno==ERANGE)
+           {
+            errno=0;
+            execerror(s," resultado fuera de rango ");
+           }
+ return d;
+}
diff --git a/EjemplosBasicos/ejemplo9/math9.o b/EjemplosBasicos/ejemplo9/math9.o
new file mode 100644
index 0000000..115d5cb
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/math9.o differ
diff --git a/EjemplosBasicos/ejemplo9/prueba.txt b/EjemplosBasicos/ejemplo9/prueba.txt
new file mode 100644
index 0000000..4bf3672
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/prueba.txt
@@ -0,0 +1,10 @@
+dato:=1;
+while(dato<10)
+ {
+  if (dato%2==0) print dato
+	else print -dato;
+  
+  dato:=dato+1;
+ };
+read(dato);
+print dato;
diff --git a/EjemplosBasicos/ejemplo9/symbol9.c b/EjemplosBasicos/ejemplo9/symbol9.c
new file mode 100644
index 0000000..bce20c2
--- /dev/null
+++ b/EjemplosBasicos/ejemplo9/symbol9.c
@@ -0,0 +1,80 @@
+#include <string.h>
+#include <stdlib.h>
+
+#include "ejemplo9.h"
+#include "ejemplo9.tab.h" /* Se genera al ejecutar yacc -d hoc5.y */
+
+/* Tabla de simbolos: lista simple encadenada */
+static Symbol *symlist=0; 
+
+/**********************************************************************/
+/** Nombre: lookup                                                   **/
+/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
+/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
+/**        a la palabra; en caso contrario, devuelve NULL.           **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
+/** Parametros:                                                      **/ 
+/**  Nombre: s                                                       **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
+/**     Mision: suministra el nombre de la palabra buscada.          **/
+/**********************************************************************/
+Symbol *lookup (char *s) 
+{
+	Symbol *sp;
+
+	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
+		if (strcmp(sp->nombre,s)==0) return sp;
+	return 0;
+}
+
+/************************************************************************/
+/** Nombre: install                                                    **/
+/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
+/**        indicando el token que le corresponde y su valor inicial.   **/
+/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
+/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
+/** Parametros:                                                        **/ 
+/**  Nombre: s                                                         **/
+/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
+/**     Mision: suministra el nombre de la palabra a insertar.         **/
+/**  Nombre: t                                                         **/
+/**	Tipo:   entero "int"                                           **/
+/**     Mision: indica el token de la palabra.                         **/
+/**  Nombre: d                                                         **/
+/**	Tipo:   real de doble precision "double"                       **/
+/**     Mision: suministra un valor inicial.                           **/
+/************************************************************************/
+Symbol *install(char *s, int t, double d)
+{
+ Symbol *sp;
+ char *emalloc();
+
+ sp=(Symbol *) emalloc(sizeof(Symbol));
+ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
+ strcpy(sp->nombre,s);
+ sp->tipo=t;
+ sp->u.val=d;
+ sp->siguiente=symlist;
+ symlist=sp;
+ return sp;
+}
+
+/************************************************************************/
+/** Nombre: emalloc                                                    **/
+/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
+/**        se producen errores.                                        **/
+/**        Devuelve un puntero a la memoria reservada.                 **/
+/** Tipo de resultado: Puntero a caracter  "char *"                    **/
+/** Parametros:                                                        **/ 
+/**  Nombre: n                                                         **/
+/**	Tipo:   entero sin signo "unsigned"                            **/
+/**     Mision: indica la cantidad de bytes que se deben reservar      **/
+/************************************************************************/
+
+char *emalloc(unsigned n)
+{
+	char *p;
+	p=malloc(n);
+	if (p==0) execerror("\nFalta memoria\n",(char *)0);
+	return p;
+}
diff --git a/EjemplosBasicos/ejemplo9/symbol9.o b/EjemplosBasicos/ejemplo9/symbol9.o
new file mode 100644
index 0000000..74eae28
Binary files /dev/null and b/EjemplosBasicos/ejemplo9/symbol9.o differ
diff --git a/Makefile b/Makefile
index ec6e41a..51e2afc 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@ LEXICO = lexico9
 CC = gcc
 YFLAGS = -d -v
 LFLAGS = -lm -lfl
-OBJS= $(FUENTE).tab.o lex.yy.o  init9.o math9.o symbol9.o  code9.o
+OBJS= $(FUENTE).tab.o lex.yy.o  init9.o math9.o symbol9.o  code9.o auxiliar.o
 
 $(FUENTE)3.exe: $(OBJS)
 	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
@@ -25,6 +25,9 @@ math9.o:  math9.c $(FUENTE).h
 lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
 	$(CC) -c lex.yy.c
 
+auxiliar.o:  auxiliar.c $(FUENTE).h
+	$(CC) -c auxiliar.c
+
 lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
 	flex $(LEXICO).l
 
diff --git a/auxiliar.c b/auxiliar.c
new file mode 100644
index 0000000..3c437ef
--- /dev/null
+++ b/auxiliar.c
@@ -0,0 +1,12 @@
+#include <stdio.h>
+#include <string.h>
+#include "auxiliar.h"
+
+void hacerMinuscula(string yytext)
+{
+	char *i;
+	for(i = yytext; *i; i++)
+	{
+		*i = tolower((unsigned char)*i;)
+	}
+}
\ No newline at end of file
diff --git a/auxiliar.h b/auxiliar.h
new file mode 100644
index 0000000..181407b
--- /dev/null
+++ b/auxiliar.h
@@ -0,0 +1,2 @@
+
+void hacerMinuscula(yytext):
\ No newline at end of file
diff --git a/ejemplo9.h b/ejemplo9.h
index da00f1b..0ac111d 100644
--- a/ejemplo9.h
+++ b/ejemplo9.h
@@ -2,10 +2,11 @@ typedef struct Symbol
          { /* entrada en la tabla de simbolos */
              char *nombre;
 	     short tipo;  /* NUMBER,VAR,FUNCION,INDEFINIDA,CONSTANTE*/
-	     union {
+	     struct {
 		    double val;        /* VAR, NUMBER, INDEFINIDA, CONSTANTE */
 		    double (*ptr)();   /* FUNCION */
-                   } u;
+            char * cadena;
+         } u;
              struct Symbol * siguiente;
          } Symbol;
 
diff --git a/ejemplo9.y b/ejemplo9.y
index 9003cdb..41e9bd8 100644
--- a/ejemplo9.y
+++ b/ejemplo9.y
@@ -28,44 +28,49 @@
        Inst *inst;     /* instruccion de maquina */
 }
 
-%token <sym> NUMBER VAR CONSTANTE FUNCION0_PREDEFINIDA FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA INDEFINIDA PRINT WHILE IF ELSE READ
-%type <inst> stmt asgn expr stmtlist cond while if end
+%token FIN_SENTENCIA
+%token <sym> NUMBER VAR VAR_CADENA CADENA CONSTANTE FUNCION0_PREDEFINIDA FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA INDEFINIDA READ READ_CHAR PRINT PRINT_CHAR IF THEN ELSE END_IF WHILE DO END_WHILE REPEAT UNTIL FOR SINCE INC END_FOR DELETE PLACE
+%type <inst> stmt asgn expr  stmtlist cond while if end exprcadena
 %right ASIGNACION
 %left O_LOGICO
 %left Y_LOGICO
-%left MAYOR_QUE MENOR_QUE MENOR_IGUAL MAYOR_IGUAL DISTINTO IGUAL
+%left MAYOR_QUE MENOR_QUE MENOR_IGUAL MAYOR_IGUAL DISTINTO IGUAL DISTINTO_QUE
+%left CONCATENACION
 %left '+' '-'
-%left '*' '/' '%'
+%left '*' '/' MODULO POTENCIA
 %left UNARIO NEGACION
 %right '^'
 %%
 
 list :    /* nada: epsilon produccion */
-        | list stmt  ';' {code(STOP); return 1;}
-        | list error ';'   {yyerrok;}
+        | list stmt  FIN_SENTENCIA {code(STOP); return 1;}
+        | list error FIN_SENTENCIA   {yyerrok;}
         ;
 
 stmt :    /* nada> epsilon produccion */  {$$=progp;}
         | asgn          {code(pop2);}
-	| PRINT expr    {code(escribir); $$ = $2;}
+	      | PRINT '(' expr ')'    {code(escribir); $$ = $3;}
         | READ '(' VAR ')'    {code2(leervariable,(Inst)$3);}
-        | while cond stmt end
+        | READ_CHAR '(' VAR ')' { code2(leer_cadena,(Inst)$3);}
+        | READ_CHAR '(' VAR_CADENA ')' { code2(leer_cadena,(Inst)$3);}
+        | PRINT_CHAR '(' exprcadena ')' { code(escribir_cadena); $$ = $3;}
+        | while WHILE cond DO stmtlist END_WHILE end
                   {
-                   ($1)[1]=(Inst)$3; /* cuerpo del bucle */
-                   ($1)[2]=(Inst)$4; /* siguiente instruccion al bucle */
+                   ($1)[1]=(Inst)$5; /* cuerpo del bucle */
+                   ($1)[2]=(Inst)$7; /* siguiente instruccion al bucle */
                   }
-        | if cond stmt end /* proposicion if sin parte else */
+        | if cond THEN stmtlist END_IF end /* proposicion if sin parte else */
                   {
-                   ($1)[1]=(Inst)$3; /* cuerpo del if */
-                   ($1)[3]=(Inst)$4; /* siguiente instruccion al if */
+                   ($1)[1]=(Inst)$4; /* cuerpo del if */
+                   ($1)[3]=(Inst)$6; /* siguiente instruccion al if */
                   }
-        | if cond stmt end ELSE stmt end /* proposicion if con parte else */
+        | if cond THEN stmtlist  end ELSE stmtlist END_IF end /* proposicion if con parte else */
                   {
-                   ($1)[1]=(Inst)$3; /* cuerpo del if */
-                   ($1)[2]=(Inst)$6; /* cuerpo del else */
-                   ($1)[3]=(Inst)$7; /* siguiente instruccion al if-else */
+                   ($1)[1]=(Inst)$4; /* cuerpo del if */
+                   ($1)[2]=(Inst)$7; /* cuerpo del else */
+                   ($1)[3]=(Inst)$9; /* siguiente instruccion al if-else */
                   }
-        | '{' stmtlist '}'  {$$ = $2;}
+        /*| '{' stmtlist '}'  {$$ = $2;} */
         ;
 
 
@@ -87,7 +92,7 @@ end :    /* nada: produccion epsilon */  {code(STOP); $$ = progp;}
         ;
 
 stmtlist:  /* nada: prodcuccion epsilon */ {$$=progp;}
-        | stmtlist stmt ';'
+        | stmtlist stmt FIN_SENTENCIA
         ;
 
 expr :    NUMBER     		{$$=code2(constpush,(Inst)$1);}
@@ -103,8 +108,8 @@ expr :    NUMBER     		{$$=code2(constpush,(Inst)$1);}
         | expr '-' expr 	{code(restar);}
         | expr '*' expr 	{code(multiplicar);}
         | expr '/' expr 	{code(dividir);}
-        | expr '%' expr 	{code(modulo);}
-        | expr '^' expr 	{code(potencia);}
+        | expr MODULO expr 	{code(modulo);}
+        | expr POTENCIA expr 	{code(potencia);}
         |'-' expr %prec UNARIO 	{$$=$2; code(negativo);}
         |'+' expr %prec UNARIO 	{$$=$2; code(positivo);}
         | expr MAYOR_QUE expr 	{code(mayor_que);}
@@ -116,7 +121,14 @@ expr :    NUMBER     		{$$=code2(constpush,(Inst)$1);}
         | expr Y_LOGICO expr 	{code(y_logico);}
         | expr O_LOGICO expr 	{code(o_logico);}
         | NEGACION expr 	{$$=$2; code(negacion);}
-	;
+        | expr CONCATENACION expr {code(concatenar);}
+      	;
+
+exprcadena :    CADENA        {$$=code2(charpush,(Inst)$1);}
+        | VAR_CADENA {$$=code3(varpush,(Inst)$1,eval_cadena);}
+        | exprcadena CONCATENACION exprcadena {code(concatenar);}
+        ;
+
 
 %%
 
@@ -182,3 +194,4 @@ void fpecatch()     /*  atrapa errores de punto flotante */
 {
  execerror("error de punto flotante ",(char *)0);
 }
+
diff --git a/factorial.txt b/factorial.txt
new file mode 100644
index 0000000..acea1a4
--- /dev/null
+++ b/factorial.txt
@@ -0,0 +1,16 @@
+read(dato);
+
+if (dato < 0) f := 0
+else
+    {
+     i:=dato;
+     f := 1;
+
+     while(i>1)
+       {
+        f := f * i;
+        i := i-1;
+      };
+    };
+
+print f; 
diff --git a/init9.c b/init9.c
index d4144f7..6fa3e85 100644
--- a/init9.c
+++ b/init9.c
@@ -25,11 +25,29 @@ static struct{   /* palabras clave */
               char *nombre;
 	      int  kval;
 	      } keywords[] = {
-                              "if",        IF,
-			      "else",      ELSE,
-			      "while",     WHILE,
-			      "print",     PRINT,
-                              "read",      READ,
+                  /*"mod",        	MOD,
+                  "o",				O,
+                  "y",				Y,
+                  "no",				NO,*/ //estas hay que ponerlas independientes como reglas de lex
+                  "leer",				READ,
+                  "leer_cadena",		READ_CHAR,
+                  "escribir",			PRINT,
+                  "escribir_cadena",	PRINT_CHAR,
+                  "si",					IF,
+                  "entonces",			THEN,
+			      "si_no",      		ELSE,
+			      "fin_si",				END_IF,
+			      "mientras",     		WHILE,
+			      "hacer",				DO,
+			      "fin_mientras",		END_WHILE,
+			      "repetir",			REPEAT,
+			      "hasta",				UNTIL,
+			      "para",				FOR,
+			      "desde",				SINCE,
+			      "paso",				INC, //esto es un incremento positivo o negativo
+			      "fin_para",			END_FOR,
+			      "borrar",				DELETE,
+			      "lugar",				PLACE,
 			      0,           0,
                              };
 
@@ -90,3 +108,4 @@ init()
       s->u.ptr=funciones2[i].func;
      }
 }
+
diff --git a/lexico9.l b/lexico9.l
index c3b9522..1d6d911 100644
--- a/lexico9.l
+++ b/lexico9.l
@@ -2,13 +2,16 @@
 #include "macros.h"
 #include "ejemplo9.h"
 #include "ejemplo9.tab.h"
+#include "auxiliar.h"
 extern char *progname;
 extern int lineno;
 %}
 /* definiciones regulares */
-numero        [0-9]
-letra         [a-zA-Z]
-identificador {letra}({letra}|{numero})*
+numero          {digito}+(\.{digito}+)?(E[+\-]?{digito}+)?
+letra           [a-zA-Z]
+subrayado       [_]
+identificador   {letra}({letra}|{numero}|{subrayado}({letra}|{numero}))*
+cadena          [\'].*[\']
 
 %%
 [ \t] { ; } /* saltar los espacios y los tabuladores */
@@ -20,21 +23,30 @@ identificador {letra}({letra}|{numero})*
 				   return NUMBER;}
 
 {identificador} { Symbol *s;
+                    hacerMinusculas(yytext);
                    if ((s=lookup(yytext)) == 0)
                                s = install (yytext, INDEFINIDA, 0.0);
                     yylval.sym = s;
                     return s->tipo == INDEFINIDA ? VAR : s->tipo;}
 
-">="	{return MAYOR_IGUAL;}
-"<="	{return MENOR_IGUAL;}
-"=="	{return IGUAL;}
-"!="	{return DISTINTO;}
-">"	{return MAYOR_QUE;}
-"<"	{return MENOR_QUE;}
-"!"	{return NEGACION;}
-"||"	{return O_LOGICO;}
-"&&"	{return Y_LOGICO;}
-":="      {return ASIGNACION;}
+">="	       {return MAYOR_IGUAL;}
+"<="	       {return MENOR_IGUAL;}
+"=="	       {return IGUAL;}
+"!="	       {return DISTINTO;}
+">"	           {return MAYOR_QUE;}
+"<"	           {return MENOR_QUE;}
+":="           {return ASIGNACION;}
+"**"           {return POTENCIA;}
+"||"           {return CONCATENACION;}
+
+
+#[Mm][Oo][Dd]   {return MODULO;}
+#[Oo]           {return O_LOGICO;}
+#[Yy]           {return Y_LOGICO;}
+#[Nn][Oo]       {return NEGACION;}
+
+
+
 ^#       {printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
 \n      {lineno++; } /* no se devuelve nada, contina el analisis lxico */
 ^\$[^\n]*  { /* Ejecucion de un comando del shell */
diff --git a/macros.h b/macros.h
index 3fc542f..edbd670 100644
--- a/macros.h
+++ b/macros.h
@@ -4,4 +4,4 @@
 #define APAGA        printf("%c[0m",27)
 #define INVERSO      printf("%c[7m",27)
 #define SUBRAYA      printf("%c[4m",27)
-#define INTENSIDAD   printf("%c[1m",27)
+#define INTENSIDAD   printf("%c[1m",27)
\ No newline at end of file
diff --git a/math9.c b/math9.c
index 650eaa5..4ab21d4 100644
--- a/math9.c
+++ b/math9.c
@@ -8,7 +8,6 @@ extern int errno;
 /* Prototipo de la funcion que comprueba errores matematicos **/
 double errcheck(double d, char *s);
 
-
 /*****************************************************************/
 /** Nombre: Log                                                 **/
 /** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
diff --git a/prueba.txt b/prueba.txt
new file mode 100644
index 0000000..4bf3672
--- /dev/null
+++ b/prueba.txt
@@ -0,0 +1,10 @@
+dato:=1;
+while(dato<10)
+ {
+  if (dato%2==0) print dato
+	else print -dato;
+  
+  dato:=dato+1;
+ };
+read(dato);
+print dato;
diff --git a/stage.diff b/stage.diff
new file mode 100644
index 0000000..7705ac0
--- /dev/null
+++ b/stage.diff
@@ -0,0 +1,1210 @@
+diff --git a/Makefile b/Makefile
+new file mode 100644
+index 0000000..d2dbb35
+--- /dev/null
++++ b/Makefile
+@@ -0,0 +1,39 @@
++FUENTE = ejemplo9
++LEXICO = lexico9
++
++
++CC = gcc
++YFLAGS = -d -v 
++LFLAGS = -lm -lfl 
++OBJS= $(FUENTE).tab.o lex.yy.o  init9.o math9.o symbol9.o  code9.o
++
++$(FUENTE)3.exe: $(OBJS) 
++	$(CC) $(OBJS) $(LFLAGS) -o $(FUENTE).exe
++
++code9.o:  code9.c $(FUENTE).h
++	$(CC) -c code9.c
++
++init9.o:  init9.c $(FUENTE).h $(FUENTE).tab.h
++	$(CC) -c init9.c
++
++symbol9.o:  symbol9.c $(FUENTE).h $(FUENTE).tab.h
++	$(CC) -c symbol9.c
++
++math9.o:  math9.c $(FUENTE).h
++	$(CC) -c math9.c
++
++lex.yy.o:  lex.yy.c $(FUENTE).tab.h $(FUENTE).h
++	$(CC) -c lex.yy.c
++
++lex.yy.c: $(LEXICO).l $(FUENTE).tab.h $(FUENTE).h
++	flex $(LEXICO).l
++
++$(FUENTE).tab.o:  $(FUENTE).tab.c $(FUENTE).tab.h $(FUENTE).h
++	$(CC) -c $(FUENTE).tab.c
++
++$(FUENTE).tab.c $(FUENTE).tab.h:  $(FUENTE).y $(FUENTE).h 
++	bison $(YFLAGS) $(FUENTE).y
++
++#Opcion para borrar los ficheros objetos y auxiliares
++clean: 
++	rm -f  $(OBJS) $(FUENTE).tab.[ch] lex.yy.c $(FUENTE).exe $(FUENTE).output
+diff --git a/code9.c b/code9.c
+new file mode 100644
+index 0000000..2c689a2
+--- /dev/null
++++ b/code9.c
+@@ -0,0 +1,493 @@
++#include <stdio.h>
++#include  <math.h>
++
++#include "ejemplo9.h"
++#include "ejemplo9.tab.h"
++
++#include "macros.h"
++
++#define NSTACK 256              /* Dimension maxima de la pila */
++static Datum stack[NSTACK];     /* La pila */
++static Datum *stackp;           /* siguiente lugar libre en la pila */
++
++#define NPROG 2000 
++Inst prog[NPROG];  /* La maquina */
++Inst *progp;       /* Siguiente lugar libre para la generacion de codigo */
++
++Inst *pc; /* Contador de programa durante la ejecucion */
++
++initcode() /* inicializacion para la generacion de codigo */
++{
++ stackp = stack;
++ progp = prog;
++}
++
++push(Datum d) /* meter d en la pila */
++{
++ 
++/* Comprobar que hay espacio en la pila para el nuevo valor o variable */
++ 
++ if (stackp >= &stack[NSTACK])
++     execerror (" Desborde superior de la pila ", (char *) 0);
++ 
++ *stackp++ =d; /* Apilar la variable o el numero y */
++               /* desplazar el puntero actual de la pila */
++}
++
++
++Datum pop() /* sacar y devolver de la pila el elemento de la cima */
++{
++ 
++/* Comprobar que no se intenta leer fuera de la pila */ 
++/* En teoria no ocurrira nunca */
++ 
++ if (stackp <= stack)
++     execerror (" Desborde inferior de la pila ", (char *) 0);
++ 
++ --stackp;          /* Volver hacia atras una posicion en la pila */
++ return(*stackp);   /* Devolver variable o numero */
++}
++
++pop2() /* sacar y  NO devolver el elemento de la cima de la pila */
++{
++ 
++/* Comprobar que no se intenta leer fuera de la pila */ 
++/* En teoria no ocurrira nunca */
++ 
++ if (stackp <= stack)
++     execerror (" Desborde inferior de la pila ", (char *) 0);
++ 
++ --stackp;          /* Volver hacia atras una posicion en la pila */
++}
++
++Inst *code(Inst f) /* Instalar una instruccion u operando */
++{
++ Inst *oprogp = progp;   /* Puntero auxiliar */
++ 
++/* Comprobar que hay espacio en el vector de instrucciones */ 
++
++ if (progp >= &prog[NPROG])
++     execerror (" Programa demasiado grande", (char *) 0);
++ 
++ *progp=f;        /* Asignar la instruccion o el puntero a la estructura */
++ progp++;         /* Desplazar una posicion hacia adelante */
++ return (oprogp);
++}
++
++
++execute(Inst *p)  /* Ejecucion con la maquina */
++{
++ 
++/* El contador de programa pc se inicializa con la primera instruccion a */ 
++/* ejecutar */
++ 
++ for (pc=p; *pc != STOP;   )
++    (*(*pc++))();              /* Ejecucion de la instruccion y desplazar */
++}                              /* el contador de programa pc */
++
++/****************************************************************************/
++/****************************************************************************/
++
++assign() /* asignar el valor superior al siguiente valor */
++{
++ Datum d1,d2;
++ d1=pop();    /* Obtener variable */
++ d2=pop();    /* Obtener numero   */
++ 
++ if (d1.sym->tipo != VAR && d1.sym->tipo != INDEFINIDA)
++   execerror(" asignacion a un elemento que no es una variable ", 
++	     d1.sym->nombre);
++  d1.sym->u.val=d2.val;   /* Asignar valor   */
++  d1.sym->tipo=VAR;
++  push(d2);               /* Apilar variable */
++}
++
++constpush()  /* meter una constante en la pila */
++{
++ Datum d;
++ 
++ d.val= ((Symbol *)*pc++)->u.val;
++ push(d);
++}
++
++dividir() /* dividir los dos valores superiores de la pila */
++{
++ Datum d1,d2;
++ 
++ d2=pop();      /* Obtener el primer numero  */
++ d1=pop();      /* Obtener el segundo numero */
++ 
++/* Comprobar si hay division por 0 */ 
++ 
++ if (d2.val == 0.0)
++     execerror (" Division por cero ", (char *) 0);
++ 
++ d1.val = d1.val / d2.val;    /* Dividir             */
++ push(d1);                    /* Apilar el resultado */
++}
++
++escribir() /* sacar de la pila el valor superior y escribirlo */
++{
++ Datum d;
++ 
++ d=pop();  /* Obtener numero */
++ 
++ printf("\t ---> %.8g\n",d.val);
++}
++
++eval() /* evaluar una variable en la pila */
++{
++ Datum d;
++ 
++ d=pop();  /* Obtener variable de la pila */
++ 
++/* Si la variable no esta definida */ 
++ if (d.sym->tipo == INDEFINIDA) 
++     execerror (" Variable no definida ", d.sym->nombre);
++ 
++ d.val=d.sym->u.val;  /* Sustituir variable por valor */
++ push(d);             /* Apilar valor */
++}
++
++funcion0() /* evaluar una funcion predefinida sin parametros */
++{
++ Datum d;
++ 
++ d.val= (*(double (*)())(*pc++))();
++ push(d);
++}
++
++funcion1() /* evaluar una funcion predefinida con un parametro */
++{
++ Datum d;
++ 
++ d=pop();  /* Obtener parametro para la funcion */
++
++ d.val= (*(double (*)())(*pc++))(d.val);
++ push(d);
++}
++
++funcion2() /* evaluar una funcion predefinida con dos parametros */
++{
++ Datum d1,d2;
++ 
++ d2=pop();  /* Obtener parametro para la funcion */
++ d1=pop();  /* Obtener parametro para la funcion */
++
++ d1.val= (*(double (*)())(*pc++))(d1.val,d2.val);
++ push(d1);
++}
++
++/* resto de la division entera del segundo valor de la pila */
++/* por el valor de la cima */
++modulo() 
++{
++ Datum d1,d2;
++ 
++ d2=pop();      /* Obtener el divisor */
++ d1=pop();      /* Obtener el dividendo */
++ 
++/* Comprobar si hay division por 0 */ 
++ 
++ if (d2.val == 0.0)
++     execerror (" Division por cero ", (char *) 0);
++ 
++ d1.val = (int) d1.val % (int)  d2.val;  /* Resto */
++ push(d1);                               /* Apilar el resultado */
++}
++
++multiplicar() /* multiplicar los dos valores superiores de la pila */
++{
++ Datum d1,d2;
++ 
++ d2=pop();                   /* Obtener el primer numero  */
++ d1=pop();                   /* Obtener el segundo numero */
++ d1.val = d1.val * d2.val;   /* Multiplicar               */
++ push(d1);                   /* Apilar el resultado       */
++}
++
++negativo() /* negacion del valor superior de la pila */
++{
++ Datum d1;
++ 
++ d1=pop();              /* Obtener numero   */
++ d1.val = - d1.val;     /* Aplicar menos    */
++ push(d1);              /* Apilar resultado */
++}
++
++/* Esta funcion se puede omitir   */
++positivo() /* tomar el valor positivo del elemento superior de la pila */
++{
++ Datum d1;
++ 
++ d1=pop();              /* Obtener numero   */
++ /* d1.val = + d1.val;*/     /* Aplicar mas    */
++ push(d1);              /* Apilar resultado */
++}
++
++potencia()  /* exponenciacion de los valores superiores de la pila */
++{
++ Datum d1,d2;
++ 
++ d2=pop();                      /* Obtener exponente   */
++ d1=pop();                      /* Obtener base        */
++ 
++ if ( (d1.val>=0) || ((int)d2.val == d2.val) )
++  {
++   d1.val = pow(d1.val,d2.val);   /* Elevar a potencia   */
++   push(d1);                      /* Apilar el resultado */
++  }
++ else 
++  {
++   char digitos[20];
++   sprintf(digitos,"%lf",d1.val);
++   execerror(" radicando negativo ", digitos);
++  }
++
++}
++
++restar()   /* restar los dos valores superiores de la pila */
++{
++ Datum d1,d2;
++ 
++ d2=pop();                   /* Obtener el primer numero  */
++ d1=pop();                   /* Obtener el segundo numero */
++ d1.val = d1.val - d2.val;   /* Restar                    */
++ push(d1);                   /* Apilar el resultado       */
++}
++
++sumar()   /* sumar los dos valores superiores de la pila */
++{
++ Datum d1,d2;
++ 
++ d2=pop();                   /* Obtener el primer numero  */
++ d1=pop();                   /* Obtener el segundo numero */
++ d1.val = d1.val + d2.val;   /* Sumar                     */
++ push(d1);                   /* Apilar el resultado       */
++}
++
++varpush()  /* meter una variable en la pila */
++{
++ Datum d;
++
++ d.sym=(Symbol *)(*pc++);
++ push(d);
++}
++/****************************************************************************/
++/****************************************************************************/
++
++leervariable() /* Leer una variable numerica por teclado */
++{
++ Symbol *variable;
++ char c;
++
++ variable = (Symbol *)(*pc); 
++
++ /* Se comprueba si el identificador es una variable */ 
++  if ((variable->tipo == INDEFINIDA) || (variable->tipo == VAR))
++    { 
++    printf("Valor--> ");
++    while((c=getchar())=='\n') ;
++    ungetc(c,stdin);
++    scanf("%lf",&variable->u.val);
++    variable->tipo=VAR;
++    pc++;
++
++   }
++ else
++     execerror("No es una variable",variable->nombre);
++}           
++
++
++mayor_que()
++{
++ Datum d1,d2;
++ 
++ d2=pop();   /* Obtener el primer numero  */
++ d1=pop();   /* Obtener el segundo numero */
++ 
++ if (d1.val > d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);  /* Apilar resultado */
++}
++
++
++menor_que()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val < d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);    /* Apilar el resultado */
++}
++
++
++igual()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val == d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);    /* Apilar resultado */
++}
++
++mayor_igual()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val >= d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);    /* Apilar resultado */
++}
++
++
++menor_igual()
++{
++ Datum d1,d2;
++ 
++ d2=pop();     /* Obtener el primer numero  */
++ d1=pop();     /* Obtener el segundo numero */
++ 
++ if (d1.val <= d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);     /* Apilar resultado */
++}
++
++distinto()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val != d2.val)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);    /* Apilar resultado */
++}
++
++
++y_logico()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val==1 && d2.val==1)
++   d1.val= 1;
++ else 
++   d1.val=0;
++ 
++ push(d1);    /* Apilar el resultado */
++}
++
++
++o_logico()
++{
++ Datum d1,d2;
++ 
++ d2=pop();    /* Obtener el primer numero  */
++ d1=pop();    /* Obtener el segundo numero */
++ 
++ if (d1.val==1 || d2.val==1)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);    /* Apilar resultado */
++}
++
++
++negacion()
++{
++ Datum d1;
++ 
++ d1=pop();   /* Obtener numero */
++ 
++ if (d1.val==0)
++   d1.val= 1;
++ else
++   d1.val=0;
++ 
++ push(d1);   /* Apilar resultado */
++}
++
++
++whilecode()
++{
++ Datum d;
++ Inst *savepc = pc;    /* Puntero auxiliar para guardar pc */
++
++ execute(savepc+2);    /* Ejecutar codigo de la condicion */
++ 
++ d=pop();    /* Obtener el resultado de la condicion de la pila */
++ 
++ while(d.val)   /* Mientras se cumpla la condicion de que no sea nulo */
++    {
++     execute(*((Inst **)(savepc)));   /* Ejecutar codigo del bucle, con el doble casting ejecuta el cuerpo del bucle */
++     execute(savepc+2);               /* Ejecutar condicion */
++     d=pop();              /* Obtener el resultado de la condicion */
++    }
++ 
++/* Asignar a pc la posicion del vector de instrucciones que contiene */  
++/* la siguiente instruccion a ejecutar */ 
++ 
++ pc= *((Inst **)(savepc+1));  
++}
++
++ifcode()
++{
++ Datum d;
++ Inst *savepc = pc;   /* Puntero auxiliar para guardar pc */
++
++ execute(savepc+3);   /* Ejecutar condicion */
++ d=pop();             /* Obtener resultado de la condicion */
++ 
++ 
++/* Si se cumple la condici\A2n ejecutar el cuerpo del if */
++ 
++ if(d.val)
++   execute(*((Inst **)(savepc)));
++ 
++/* Si no se cumple la condicion se comprueba si existe parte else   */
++/* Esto se logra ya que la segunda posicion reservada contendria el */
++/* puntero a la primera instruccion del cuerpo del else en caso de  */
++/* existir, si no existe sera\A0 STOP, porque a la hora de generar    */
++/* codigo se inicializa con STOP.                                   */
++
++ else if  (*((Inst **)(savepc+1)))  /* parte else */
++   execute(*((Inst **)(savepc+1)));
++ 
++
++/* Asignar a pc la posicion del vector de instrucciones que contiene */  
++/* la siguiente instruccion a ejecutar */ 
++ 
++ pc= *((Inst **)(savepc+2));
++}
+diff --git a/ejemplo9.h b/ejemplo9.h
+new file mode 100644
+index 0000000..4b0e75a
+--- /dev/null
++++ b/ejemplo9.h
+@@ -0,0 +1,31 @@
++typedef struct Symbol
++         { /* entrada en la tabla de simbolos */
++             char *nombre;
++	     short tipo;  /* NUMBER,VAR,FUNCION,INDEFINIDA,CONSTANTE*/  
++	     union {
++		    double val;        /* VAR, NUMBER, INDEFINIDA, CONSTANTE */
++		    double (*ptr)();   /* FUNCION */
++                   } u;
++             struct Symbol * siguiente;
++         } Symbol;
++
++Symbol *install(), *lookup();
++
++typedef union Datum { /* tipo de la pila del interprete */ 
++                     double val;
++                     Symbol *sym;
++                    } Datum;
++
++extern Datum pop();
++extern pop2();
++
++typedef int (*Inst)(); /* instruccion maquina */
++#define STOP (Inst) 0
++
++extern Inst prog[], *progp, *code();
++
++extern  assign(), constpush(), dividir(), escribir(), eval(), funcion0(),
++        funcion1(),funcion2(), modulo(), multiplicar(), negativo(), positivo(),
++        potencia(), restar(), sumar(), varpush(), ifcode(), whilecode(),
++        mayor_que(), menor_que(), mayor_igual(),menor_igual(), igual(), 
++       distinto(), y_logico(), o_logico(), negacion(), leervariable();
+diff --git a/ejemplo9.y b/ejemplo9.y
+new file mode 100644
+index 0000000..edba18c
+--- /dev/null
++++ b/ejemplo9.y
+@@ -0,0 +1,185 @@
++/*
++
++ Ejemplo 9
++ 
++  Se ha ampliado el ejemplo 8 para permitir 
++  - operadores relacionales y lgicos
++  - sentencia condicional: if
++  - sentencia iterativa: while
++  - ejecutar las sentencias contenidas en un fichero indicado en la lnea de comandos
++    Por ejemplo:
++       > ./ejemplo9.exe factorial.txt
++*/
++
++%{
++#include <stdio.h>
++#include <math.h>
++
++#include "ejemplo9.h"
++
++#include "macros.h"
++
++#define code2(c1,c2)         code(c1); code(c2)
++#define code3(c1,c2,c3)      code(c1); code(c2); code(c3)
++%}
++
++%union{             
++       Symbol *sym;    /* puntero a la tabla de simbolos */
++       Inst *inst;     /* instruccion de maquina */
++}
++
++%token <sym> NUMBER VAR CONSTANTE FUNCION0_PREDEFINIDA FUNCION1_PREDEFINIDA FUNCION2_PREDEFINIDA INDEFINIDA PRINT WHILE IF ELSE READ
++%type <inst> stmt asgn expr stmtlist cond while if end 
++%right ASIGNACION
++%left O_LOGICO
++%left Y_LOGICO
++%left MAYOR_QUE MENOR_QUE MENOR_IGUAL MAYOR_IGUAL DISTINTO IGUAL
++%left '+' '-'
++%left '*' '/' '%'
++%left UNARIO NEGACION
++%right '^'   
++%%
++
++list :    /* nada: epsilon produccion */ 
++        | list stmt  ';' {code(STOP); return 1;}
++        | list error ';'   {yyerrok;} 
++        ;
++
++stmt :    /* nada> epsilon produccion */  {$$=progp;}
++        | asgn          {code(pop2);}
++	| PRINT expr    {code(escribir); $$ = $2;}
++        | READ '(' VAR ')'    {code2(leervariable,(Inst)$3);}
++        | while cond stmt end  
++                  {
++                   ($1)[1]=(Inst)$3; /* cuerpo del bucle */
++                   ($1)[2]=(Inst)$4; /* siguiente instruccion al bucle */
++                  }
++        | if cond stmt end /* proposicion if sin parte else */
++                  {
++                   ($1)[1]=(Inst)$3; /* cuerpo del if */
++                   ($1)[3]=(Inst)$4; /* siguiente instruccion al if */
++                  }
++        | if cond stmt end ELSE stmt end /* proposicion if con parte else */
++                  {
++                   ($1)[1]=(Inst)$3; /* cuerpo del if */
++                   ($1)[2]=(Inst)$6; /* cuerpo del else */
++                   ($1)[3]=(Inst)$7; /* siguiente instruccion al if-else */
++                  }
++        | '{' stmtlist '}'  {$$ = $2;}
++        ;
++
++
++asgn :    VAR ASIGNACION expr { $$=$3; code3(varpush,(Inst)$1,assign);}
++        | CONSTANTE ASIGNACION expr 
++          {execerror(" NO se pueden asignar datos a constantes ",$1->nombre);}
++	;
++
++cond :    '(' expr ')' {code(STOP); $$ =$2;}
++        ;
++
++while:    WHILE      {$$= code3(whilecode,STOP,STOP);} //uno es para el cuerpo y el otro para el siguiente
++        ;
++
++if:       IF         {$$= code(ifcode); code3(STOP,STOP,STOP);}
++        ;
++
++end :    /* nada: produccion epsilon */  {code(STOP); $$ = progp;}
++        ;
++
++stmtlist:  /* nada: prodcuccion epsilon */ {$$=progp;}
++        | stmtlist stmt ';'
++        ;
++
++expr :    NUMBER     		{$$=code2(constpush,(Inst)$1);}
++        | VAR        		{$$=code3(varpush,(Inst)$1,eval);} 
++        | CONSTANTE      	{$$=code3(varpush,(Inst)$1,eval);}
++        | asgn
++        | FUNCION0_PREDEFINIDA '(' ')'      {code2(funcion0,(Inst)$1->u.ptr);}
++        | FUNCION1_PREDEFINIDA '(' expr ')' {$$=$3;code2(funcion1,(Inst)$1->u.ptr);}
++        | FUNCION2_PREDEFINIDA '(' expr ',' expr ')'
++                                            {$$=$3;code2(funcion2,(Inst)$1->u.ptr);}
++        | '(' expr ')'  	{$$ = $2;}
++        | expr '+' expr 	{code(sumar);}
++        | expr '-' expr 	{code(restar);}
++        | expr '*' expr 	{code(multiplicar);}
++        | expr '/' expr 	{code(dividir);}
++        | expr '%' expr 	{code(modulo);}
++        | expr '^' expr 	{code(potencia);}
++        |'-' expr %prec UNARIO 	{$$=$2; code(negativo);}
++        |'+' expr %prec UNARIO 	{$$=$2; code(positivo);}
++        | expr MAYOR_QUE expr 	{code(mayor_que);}
++        | expr MAYOR_IGUAL expr {code(mayor_igual);}
++        | expr MENOR_QUE expr 	{code(menor_que);}
++        | expr MENOR_IGUAL expr {code(menor_igual);}
++        | expr IGUAL expr 	{code(igual);}
++        | expr DISTINTO expr 	{code(distinto);}
++        | expr Y_LOGICO expr 	{code(y_logico);}
++        | expr O_LOGICO expr 	{code(o_logico);}
++        | NEGACION expr 	{$$=$2; code(negacion);}
++      	;
++
++%%
++
++#include <stdio.h>
++#include <ctype.h>
++#include <signal.h>
++#include <setjmp.h>
++
++jmp_buf begin;
++char *progname;
++int lineno = 1;
++/* Dispositivo de entrada estndar de yylex() */
++extern FILE * yyin;
++
++main(int argc, char *argv[])
++{
++
++ void fpecatch();
++
++ /* Si se invoca el intrprete con un fichero de entrada */
++ /* entonces se establece como dispositivo de entrada para yylex() */
++ if (argc == 2) yyin = fopen(argv[1],"r");
++
++
++ progname=argv[0];
++
++ /* inicializacion de la tabla de simbolos */
++ init();
++
++/* Establece un estado viable para continuar despues de un error */
++ setjmp(begin);
++
++ /* Establece cual va a ser la funcion para tratar errores de punto flotante */
++ signal(SIGFPE,fpecatch); /* Excepcion de punto flotante*/
++
++/* initcode inicializa el vector de intrucciones y la pila del interprete */
++ for (initcode(); yyparse(); initcode()) execute(prog);
++
++ return 0;
++
++}
++
++yyerror(char *s)
++{
++ warning(s,(char *) 0);
++}
++
++warning(char *s, char *t)
++{
++ fprintf(stderr," ** %s : %s", progname,s);
++ if (t) fprintf(stderr," ---> %s ",t);
++ fprintf(stderr,"  (linea %d)\n",lineno);
++}
++
++execerror(s,t) /* recuperacion de errores durante la ejecucion */
++char *s,*t;
++{
++ warning(s,t);
++  longjmp(begin,0);
++}
++
++void fpecatch()     /*  atrapa errores de punto flotante */
++{
++ execerror("error de punto flotante ",(char *)0);
++}
++
+diff --git a/init9.c b/init9.c
+new file mode 100644
+index 0000000..3520f3e
+--- /dev/null
++++ b/init9.c
+@@ -0,0 +1,93 @@
++#include <math.h>
++
++#include "ejemplo9.h"
++#include "ejemplo9.tab.h"
++
++/* Prototipo de una nueva funcion matematica */
++extern double integer(double x), Azar();
++/* Prototipos de funciones matematicas que "controlan" posibles errores" */
++extern double Log(double x), Log10(double x), Exp(double x), Sqrt(double x),
++              Atan2(double x, double y);
++
++static struct{
++              char *nombre;
++	      double cval;
++	      } constantes[] = {
++	                    "PI",    3.14159265358979323846,
++	                    "E",     2.71828182845904523536,
++	                    "GAMMA", 0.57721566490153286060,
++	                    "DEG",  57.29577951308232087680,
++	                    "PHI",   1.61803398874989484820,
++	                    0,       0
++	                   };
++
++static struct{   /* palabras clave */
++              char *nombre;
++	      int  kval;
++	      } keywords[] = {
++                              "if",        IF,
++			      "else",      ELSE,
++			      "while",     WHILE,
++			      "print",     PRINT,
++                              "read",      READ,
++			      0,           0,
++                             };
++
++static struct {    /* Nombres predefinidos de funciones */ 
++	       char *nombre;
++	       double (*func)();
++              } funciones0[] = {
++                               "azar", Azar,
++                                0, 0
++                              },
++                funciones1 [] = {
++	                       "seno",   sin,
++		               "coseno",   cos,
++		               "atan",  atan,
++		               "log",   Log,
++		               "log10", Log10,
++		               "exp",   Exp,
++		               "raiz",  Sqrt,
++		               "entero",   integer,
++		               "abs",   fabs,
++		               0,       0
++		              },
++              funciones2[] = {"atan2", Atan2,
++                               0, 0
++                             };
++/************************************************************************/
++/** Nombre: init                                                       **/
++/** Labor que desarrolla: Inserta  en la tabla de simbolos las         **/ 
++/**        constantes y las funciones  que se encuentran en las        **/
++/**        variables globales "consts" y "funciones"                   **/ 
++/** Tipo de resultado: entero "int" (tipo por defecto)                 **/
++/** Parametros: Ninguno.                                               **/
++/************************************************************************/
++init()
++{
++ int i;
++ Symbol *s;
++
++ for (i=0; constantes[i].nombre; i++)
++       install(constantes[i].nombre,CONSTANTE,constantes[i].cval);
++
++ for (i=0; keywords[i].nombre; i++)
++       install(keywords[i].nombre,keywords[i].kval,0.0);
++
++ for (i=0; funciones0[i].nombre; i++)
++     {
++      s=install(funciones0[i].nombre,FUNCION0_PREDEFINIDA,0.0);
++      s->u.ptr=funciones0[i].func;
++     }
++ for (i=0; funciones1[i].nombre; i++)
++     {
++      s=install(funciones1[i].nombre,FUNCION1_PREDEFINIDA,0.0);
++      s->u.ptr=funciones1[i].func;
++     }
++ for (i=0; funciones2[i].nombre; i++)
++     {
++      s=install(funciones2[i].nombre,FUNCION2_PREDEFINIDA,0.0);
++      s->u.ptr=funciones2[i].func;
++     }
++}
++
+diff --git a/lexico9.l b/lexico9.l
+new file mode 100644
+index 0000000..44f3018
+--- /dev/null
++++ b/lexico9.l
+@@ -0,0 +1,67 @@
++%{
++#include "macros.h"
++#include "ejemplo9.h"
++#include "ejemplo9.tab.h"
++extern char *progname;
++extern int lineno;
++%}
++/* definiciones regulares */
++numero        [0-9]
++letra         [a-zA-Z]
++identificador {letra}({letra}|{numero})*
++
++%%
++[ \t] { ; } /* saltar los espacios y los tabuladores */
++
++{numero}+\.?|{numero}*\.{numero}+ {double d;  
++                                   sscanf(yytext,"%lf",&d);
++                                 /* Instala el numero en la tabla de simbolos */
++				   yylval.sym=install("",NUMBER,d); 
++				   return NUMBER;}
++
++{identificador} { Symbol *s;
++                   if ((s=lookup(yytext)) == 0)
++                               s = install (yytext, INDEFINIDA, 0.0);
++                    yylval.sym = s;
++                    return s->tipo == INDEFINIDA ? VAR : s->tipo;}
++
++">="	{return MAYOR_IGUAL;}
++"<="	{return MENOR_IGUAL;}
++"=="	{return IGUAL;}
++"!="	{return DISTINTO;}
++">"	{return MAYOR_QUE;}
++"<"	{return MENOR_QUE;}
++"!"	{return NEGACION;}
++"||"	{return O_LOGICO;}
++"&&"	{return Y_LOGICO;}
++":="      {return ASIGNACION;}
++^#       {printf("\n>>>>>>> Fin del programa <<<<<<<\n"); return 0;}
++\n      {lineno++; } /* no se devuelve nada, contina el analisis lxico */
++^\$[^\n]*  { /* Ejecucion de un comando del shell */
++
++         BORRAR;
++         LUGAR(10,10);
++         if (strcmp(yytext,"$") != 0)
++            {
++             printf("\n Salida provisional al sistema operativo\n\n");
++             printf("\n comando ---> %s\n\n",yytext);
++             system(yytext+1);
++             putchar('\n');
++             }
++           else 
++            {
++             printf(" Si desea ejecutar un comando del sistema operativo ");
++             printf(" teclee: \n\t\t $comando ");
++            }
++
++         LUGAR(24,1);
++         printf(">>>>>>>> Pulse ENTER para volver al programa %s ",progname);
++         /* Espera que se pulse ENTER */
++         while(getchar()!='\n')  ;
++
++         BORRAR;
++         LUGAR(2,1);
++         printf("Continue la ejecucion del programa --> %s \n\n",progname);
++         /* no se devuelve nada, contina el analisis lxico */
++         }
++.       {return yytext[0];}
+diff --git a/macros.h b/macros.h
+new file mode 100644
+index 0000000..4b77b98
+--- /dev/null
++++ b/macros.h
+@@ -0,0 +1,7 @@
++#define LUGAR(x,y)   printf("\033[%d;%dH",x,y)
++#define BORRAR       printf("\33[2J") 
++#define PARPADEO     printf("%c[5m",27)
++#define APAGA        printf("%c[0m",27)
++#define INVERSO      printf("%c[7m",27)
++#define SUBRAYA      printf("%c[4m",27)
++#define INTENSIDAD   printf("%c[1m",27)
+diff --git a/math9.c b/math9.c
+new file mode 100644
+index 0000000..59ede65
+--- /dev/null
++++ b/math9.c
+@@ -0,0 +1,161 @@
++#include <math.h>
++#include <stdlib.h>
++#include <errno.h>
++/*  Referencia a la variable global que indica los codigos 
++   de los errores generados por las funciones matematicas */
++extern int errno;
++
++/* Prototipo de la funcion que comprueba errores matematicos **/
++double errcheck(double d, char *s);
++
++
++/*****************************************************************/
++/** Nombre: Log                                                 **/
++/** Labor que desarrolla: calcula el logaritmo neperiano de un  **/
++/**       numero real, pero comprueba antes si hay algun error  **/
++/**       en el argumento.                                      **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: x                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: indica el numero al cual se le va aplicar       **/
++/**            la funcion logaritmo neperiano                   **/
++/*****************************************************************/
++double Log(double x)
++{
++ return errcheck(log(x),"logaritmo neperiano");
++ }
++
++/*****************************************************************/
++/** Nombre: Log10                                               **/
++/** Labor que desarrolla: calcula el logaritmo decimal de un    **/
++/**       numero real, pero comprueba antes si hay algun error  **/
++/**       en el argumento.                                      **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: x                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: indica el numero al cual se le va aplicar       **/
++/**            la funcion logaritmo decimal                     **/
++/*****************************************************************/
++double Log10(double x)
++{
++ return errcheck(log10(x),"logaritmo decimal");
++}
++
++/*****************************************************************/
++/** Nombre: Exp                                                 **/
++/** Labor que desarrolla: calcula la exponencial de un numero   **/
++/**       real, pero comprueba antes si hay algun error en el   **/
++/**       argumento.                                            **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: x                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: indica el numero al cual se le va aplicar       **/
++/**            la funcion exponencial                           **/
++/*****************************************************************/
++double Exp(double x)
++{
++ return errcheck(exp(x),"exponencial");
++}
++
++/*****************************************************************/
++/** Nombre: Sqrt                                                **/
++/** Labor que desarrolla: calcula la raiz cuadrada de un numero **/
++/**       real, pero comprueba antes si hay algun error en el   **/
++/**       argumento.                                            **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: x                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: indica el numero al cual se le va aplicar       **/
++/**            la funcion raiz cuadrada.                        **/
++/*****************************************************************/
++double Sqrt(double x)
++{
++ return errcheck(sqrt(x),"raiz cuadrada");
++}
++
++/*****************************************************************/
++/** Nombre: integer                                             **/
++/** Labor que desarrolla: calcula la parte entera de un numero  **/
++/**       real, pero comprueba antes si hay algun error en el   **/
++/**       argumento.                                            **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: x                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: indica el numero al cual se le va aplicar       **/
++/**            calcular la parte entera.                        **/
++/*****************************************************************/
++
++double integer(double x)
++{
++ return  (double) (long) x;
++}
++
++/*****************************************************************/
++/** Nombre: Azar                                                **/
++/** Labor que desarrolla: calcula un numero aleatorio           **/ 
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametros:   ninguno                                       **/
++/*****************************************************************/
++double Azar()
++{
++ return (double) (long) rand() / RAND_MAX;
++}
++
++/*******************************************************************/
++/** Nombre: Atan2                                                 **/
++/** Labor que desarrolla: calcula el arco tangente doble, pero    **/
++/**       comprueba antes si hay algun error en los argumentos    **/ 
++/** Tipo de resultado: real de doble precision "double"           **/
++/** Parametro:                                                    **/
++/**  Nombre: x                                                    **/
++/**    	Tipo: real de doble precision "double"                    **/
++/**     Mision: indica el numerador de la funcion Arco tangente   **/
++/**  Nombre: y                                                    **/
++/**    	Tipo: real de doble precision "double"                    **/
++/**     Mision: indica el denominador de la funcion Arco tangente **/
++/*******************************************************************/
++
++double Atan2(double x, double y)
++{
++ return errcheck(atan(x/y),"arco tangente doble");
++}
++
++
++/*****************************************************************/
++/** Nombre: errcheck                                            **/
++/** Labor que desarrolla: comprueba si se ha producido un error **/
++/**       al realizar la evaluacion matematica del primer       **/
++/**       parametro. Si no hay error, entonces devuelve el      **/
++/**       primer parametro; en caso contrario muestra el error  **/ 
++/**       producido.                                            **/
++/** Tipo de resultado: real de doble precision "double"         **/
++/** Parametro:                                                  **/
++/**  Nombre: d                                                  **/
++/**    	Tipo: real de doble precision "double"                  **/
++/**     Mision: almacenar el valor obtenido al aplicar una      **/
++/**            funcion matematica                               **/
++/**  Nombre: s                                                  **/
++/**    	Tipo: cadena de caracteres o puntero a caracter "char *"**/
++/**     Mision: indica el nombre de la funcion que se ha        **/
++/**       utilizado para calcular el valor del primer parametro.**/
++/*****************************************************************/
++
++double errcheck(double d, char *s)
++{
++ if (errno==EDOM)
++    {
++     errno=0;
++     execerror(s," argumento fuera de dominio ");
++    }
++   else if (errno==ERANGE)
++           {
++            errno=0;
++            execerror(s," resultado fuera de rango ");
++           }
++ return d;
++}
+diff --git a/symbol9.c b/symbol9.c
+new file mode 100644
+index 0000000..bce20c2
+--- /dev/null
++++ b/symbol9.c
+@@ -0,0 +1,80 @@
++#include <string.h>
++#include <stdlib.h>
++
++#include "ejemplo9.h"
++#include "ejemplo9.tab.h" /* Se genera al ejecutar yacc -d hoc5.y */
++
++/* Tabla de simbolos: lista simple encadenada */
++static Symbol *symlist=0; 
++
++/**********************************************************************/
++/** Nombre: lookup                                                   **/
++/** Labor que desarrolla: Busca una palabra en la tabla de simbolos. **/
++/**        Si la encuentra, devuelve un puntero al nodo que contiene **/
++/**        a la palabra; en caso contrario, devuelve NULL.           **/
++/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"     **/
++/** Parametros:                                                      **/ 
++/**  Nombre: s                                                       **/
++/**	Tipo:   cadena de caracteres o puntero a char  "char *"      **/
++/**     Mision: suministra el nombre de la palabra buscada.          **/
++/**********************************************************************/
++Symbol *lookup (char *s) 
++{
++	Symbol *sp;
++
++	for (sp=symlist; sp!=(Symbol *) 0 ; sp=sp->siguiente)
++		if (strcmp(sp->nombre,s)==0) return sp;
++	return 0;
++}
++
++/************************************************************************/
++/** Nombre: install                                                    **/
++/** Labor que desarrolla: Inserta una palabra en la tabla de simbolos, **/
++/**        indicando el token que le corresponde y su valor inicial.   **/
++/**        Devuelve un puntero al nodo que contiene a la palabra.      **/
++/** Tipo de resultado: Puntero a la tabla de simbolos "Symbol *"       **/
++/** Parametros:                                                        **/ 
++/**  Nombre: s                                                         **/
++/**	Tipo:   cadena de caracteres o puntero a char  "char *"        **/
++/**     Mision: suministra el nombre de la palabra a insertar.         **/
++/**  Nombre: t                                                         **/
++/**	Tipo:   entero "int"                                           **/
++/**     Mision: indica el token de la palabra.                         **/
++/**  Nombre: d                                                         **/
++/**	Tipo:   real de doble precision "double"                       **/
++/**     Mision: suministra un valor inicial.                           **/
++/************************************************************************/
++Symbol *install(char *s, int t, double d)
++{
++ Symbol *sp;
++ char *emalloc();
++
++ sp=(Symbol *) emalloc(sizeof(Symbol));
++ sp->nombre=emalloc(strlen(s)+1); /* +1 para el caracter nulo '\0' */
++ strcpy(sp->nombre,s);
++ sp->tipo=t;
++ sp->u.val=d;
++ sp->siguiente=symlist;
++ symlist=sp;
++ return sp;
++}
++
++/************************************************************************/
++/** Nombre: emalloc                                                    **/
++/** Labor que desarrolla: reserva memoria dinamica y comprueba que no  **/
++/**        se producen errores.                                        **/
++/**        Devuelve un puntero a la memoria reservada.                 **/
++/** Tipo de resultado: Puntero a caracter  "char *"                    **/
++/** Parametros:                                                        **/ 
++/**  Nombre: n                                                         **/
++/**	Tipo:   entero sin signo "unsigned"                            **/
++/**     Mision: indica la cantidad de bytes que se deben reservar      **/
++/************************************************************************/
++
++char *emalloc(unsigned n)
++{
++	char *p;
++	p=malloc(n);
++	if (p==0) execerror("\nFalta memoria\n",(char *)0);
++	return p;
++}
